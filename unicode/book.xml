<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
 "https://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [

<!ENTITY tr9ver  "42">
<!ENTITY tr14ver "45">
<!ENTITY tr24ver "31">
<!ENTITY tr29ver "37">
<!ENTITY tr51ver "18">
]>

<!--

Copyright 2014-2017 Double Precision, Inc.
See COPYING for distribution information.

-->

<article id="index">
  <title>Courier Unicode Library</title>

  <para>
    This library implements several algorithms related to the
    <ulink url="https://www.unicode.org/standard/standard.html">Unicode
    Standard</ulink>:
  </para>

  <itemizedlist>
    <listitem>
      <para>
	Look up uppercase, lowercase, and titlecase equivalents of a unicode
	character.
      </para>
    </listitem>
    <listitem>
      <para>
	Implementation of
	<ulink url="https://www.unicode.org/reports/tr29/tr29-&tr29ver;.html">grapheme
	and work breaking</ulink> rules.
      </para>
    </listitem>
    <listitem>
      <para>
	Implementation of
	<ulink url="https://www.unicode.org/reports/tr14/tr14-&tr14ver;.html">line
	breaking</ulink> rules.
      </para>
    </listitem>
    <listitem>
      <para>
	Implementation of the
	<ulink url="https://www.unicode.org/reports/tr9/tr9-&tr9ver;.html">bi-directional
	algorithm</ulink>.
      </para>
    </listitem>
    <listitem>
      <para>
	Several ancillary functions, like looking up
	the unicode character that corresponds to some HTML 4.0
	entity (such as <quote>&amp;amp;</quote>, for example), and
	determining the normal width or a double-width status of a unicode
	character. Also, an adaptation of the
	<ulink url="https://manpages.courier-mta.org/htmlman3/iconv.3.html">
	<citerefentry><refentrytitle>iconv</refentrytitle>
	<manvolnum>3</manvolnum></citerefentry></ulink>
	API for this unicode library.
      </para>
    </listitem>
    <listitem>
      <para>
	Look up the
	<ulink url="https://www.unicode.org/reports/tr24/tr24-&tr24ver;.html">Unicode
	script property</ulink>.
      </para>
    </listitem>
    <listitem>
      <para>
	Look up the
	<ulink url="https://unicode.org/notes/tn36/">category</ulink>
	property.
      </para>
    </listitem>
  </itemizedlist>

  <para>
    This library also implements C++ bindings for these algorithms.
  </para>

  <section id="status">
    <title>Current status</title>

    <para>
      The current release of the Courier Unicode library is based on the
      Unicode 13.0.0 standard.
    </para>
  </section>

  <section id="INSTALL">
    <title>Installation and usage</title>

    <para>
      Download the current version of the library from
      <ulink url="/download.html#unicode">https://www.courier-mta.org/download.html#unicode</ulink>.
      After unpacking the tarball, run the configure script, which takes
      the usual options, followed by <command>make</command>, then
      <command>make install</command>.
    </para>

    <para>
      To use the library, <quote>#include &lt;courier-unicode.h&gt;</quote> and link
      with <literal>-lcourier-unicode</literal>.
      The C++ compiler must have C++11 support. Minimum usable version of
      gcc appears to be gcc 4.4 with the <literal>-std=c++0x</literal> flag.
      Current versions of gcc use C++11, or higher, by default and do not
      require extra flags. Like with all C++ code, the same compiler, and flags,
      must be used to build code that uses this library that was used to
      build the library itself.
    </para>

    <para>
      The Courier Unicode library installs an
      <application>autoconf</application> macro to probe for C++11 support.
      In your <filename>configure.ac</filename>
    </para>

    <blockquote>
      <informalexample>
	<programlisting>
	  AX_COURIER_UNICODE_VERSION
	  AX_COURIER_UNICODE_CXXFLAGS

	  AC_SUBST(COURIER_UNICODE_CXXFLAGS)
	</programlisting>
      </informalexample>
    </blockquote>

    <para>
      Then, in <filename>Makefile.am</filename>:
    </para>

    <blockquote>
      <informalexample>
	<programlisting>
	  AM_CXXFLAGS = @COURIER_UNICODE_CXXFLAGS@
	</programlisting>
      </informalexample>
    </blockquote>

    <para>
      The <varname>AX_COURIER_UNICODE_VERSION</varname> macro
      checks the minimum library version.
      <varname>AX_COURIER_UNICODE_CXXFLAGS</varname> sets
      <varname>COURIER_UNICODE_CXXFLAGS</varname> to the appropriate option
      for older gcc compilers that require an option to enable C++11
      support.
    </para>

    <para>
      The starting point for the library documentation is
      <link linkend="courier-unicode">
	<citerefentry>
	  <refentrytitle>courier-unicode</refentrytitle>
	  <manvolnum>7</manvolnum></citerefentry></link>.
	  Refer to the included manual pages,
	  and
	  <ulink url="https://www.courier-mta.org/unicode/manpages.html"> the HTML
	  version of the man pages</ulink> for more information.
    </para>
  </section>

  <section id="manpages">
    <title>Manual pages</title>

    <section id="manpagesc">
      <title>C manual pages</title>
      <refentry id="courier-unicode">

	<refentryinfo><author><firstname>Sam</firstname><surname>Varshavchik</surname><contrib>Author</contrib></author><productname>Courier Unicode Library</productname></refentryinfo>
	<refmeta>
	  <refentrytitle>courier-unicode</refentrytitle>
	  <manvolnum>7</manvolnum>
	</refmeta>

	<refnamediv>
	  <refname>courier-unicode</refname>
	  <refpurpose>Courier Unicode Library</refpurpose>

	</refnamediv>

	<refsynopsisdiv>
	  <programlisting>
#include &lt;courier-unicode.h&gt;</programlisting>
	</refsynopsisdiv>
	<refsect1>
	  <title>DESCRIPTION</title>

	  <para>
	    This library implements several algorithms related to the
	    <ulink url="https://www.unicode.org/standard/standard.html">Unicode
	    Standard</ulink>.
	    This library uses
	    <ulink url="https://manpages.courier-mta.org/htmlman3/iconv.3.html"
		   ><citerefentry><refentrytitle>iconv</refentrytitle>
	    <manvolnum>3</manvolnum></citerefentry></ulink> to convert
	      text in a given character set to unicode. Any character set
	      displayed by <command>iconv --list</command> can be specified
	      for the corresponding character set parameter. Additionally,
	      <filename>courier-unicode.h</filename> defines a special character
	      string <literal>unicode_x_imap_modutf7</literal> that specifies
	      the pseudo-character set for the modified-UTF7
	      encoding used in IMAP. This string can also be appended by
	      a space, and up to fifteen additional US-ASCII characters.
	      The resulting character set also encodes these additional
	      characters, in addition to unicode characters, with
	      modified-UTF7.
	  </para>

	  <para>
	    The C++ compiler must have C++11 support. Minimum usable version of
	    gcc appears to be gcc 4.4 with the <literal>-std=c++0x</literal>
	    flag. Current versions of gcc use C++11, or higher, by default and
	    do not require extra flags. Consult the packaging documentation
	    for the Courier Unicode Library for information on any
	    compiler flags that are needed to build software that links
	    with this library.
	  </para>
	</refsect1>
	<refsect1>
	  <title>SEE ALSO</title>

	  <para>
	    <link linkend="unicode_bidi">
	      <citerefentry><refentrytitle>unicode_bidi</refentrytitle>
	      <manvolnum>3</manvolnum></citerefentry></link>,
	    <link linkend="unicode_category_lookup">
	      <citerefentry><refentrytitle>unicode_category_lookup</refentrytitle>
	      <manvolnum>3</manvolnum></citerefentry></link>,
	    <link linkend="unicode_convert">
	      <citerefentry><refentrytitle>unicode_convert</refentrytitle>
	      <manvolnum>3</manvolnum></citerefentry></link>,
	    <link linkend="unicode_default_chset">
	      <citerefentry><refentrytitle>unicode_default_chset</refentrytitle>
	      <manvolnum>3</manvolnum></citerefentry></link>,
	    <link linkend="unicode_emoji_lookup">
	      <citerefentry><refentrytitle>unicode_emoji_lookup</refentrytitle>
	      <manvolnum>3</manvolnum></citerefentry></link>,
	    <link linkend="unicode_html40ent_lookup">
	      <citerefentry><refentrytitle>unicode_html40ent_lookup</refentrytitle>
	      <manvolnum>3</manvolnum></citerefentry></link>,
	    <link linkend="unicode_grapheme_break">
	      <citerefentry><refentrytitle>unicode_grapheme_break</refentrytitle>
	      <manvolnum>3</manvolnum></citerefentry></link>,
	    <link linkend="unicode_line_break">
	      <citerefentry><refentrytitle>unicode_line_break</refentrytitle>
	      <manvolnum>3</manvolnum></citerefentry></link>,
	    <link linkend="unicode_script">
	      <citerefentry><refentrytitle>unicode_script</refentrytitle>
	      <manvolnum>3</manvolnum></citerefentry></link>,
	    <link linkend="unicode_uc">
	      <citerefentry><refentrytitle>unicode_uc</refentrytitle>
	      <manvolnum>3</manvolnum></citerefentry></link>,
	    <link linkend="unicode_word_break">
	      <citerefentry><refentrytitle>unicode_word_break</refentrytitle>
	      <manvolnum>3</manvolnum></citerefentry></link>,
	    <link linkend="unicode__bidi">
	      <citerefentry><refentrytitle>unicode::bidi</refentrytitle>
	      <manvolnum>3</manvolnum></citerefentry></link>,
	    <link linkend="unicode__iconvert__convert">
	      <citerefentry><refentrytitle>unicode::iconvert::convert</refentrytitle>
	      <manvolnum>3</manvolnum></citerefentry></link>,
	    <link linkend="unicode__iconvert__convert_tocase">
	      <citerefentry><refentrytitle>unicode::iconvert::convert_tocase</refentrytitle>
	      <manvolnum>3</manvolnum></citerefentry></link>,
	    <link linkend="unicode__iconvert__fromu">
	      <citerefentry><refentrytitle>unicode::iconvert::fromu</refentrytitle>
	      <manvolnum>3</manvolnum></citerefentry></link>,
	    <link linkend="unicode__iconvert__tou">
	      <citerefentry><refentrytitle>unicode::iconvert::tou</refentrytitle>
	      <manvolnum>3</manvolnum></citerefentry></link>,
	    <link linkend="unicode__tolower">
	      <citerefentry><refentrytitle>unicode::tolower</refentrytitle>
	      <manvolnum>3</manvolnum></citerefentry></link>,
	    <link linkend="unicode__linebreak">
	      <citerefentry><refentrytitle>unicode::linebreak</refentrytitle>
	      <manvolnum>3</manvolnum></citerefentry></link>,
	    <link linkend="unicode__wordbreak">
	      <citerefentry><refentrytitle>unicode::wordbreak</refentrytitle>
	      <manvolnum>3</manvolnum></citerefentry></link>.
	  </para>
	</refsect1>
      </refentry>

      <refentry id="unicode_bidi">
	<refentryinfo><author><firstname>Sam</firstname><surname>Varshavchik</surname><contrib>Author</contrib></author><productname>Courier Unicode Library</productname></refentryinfo>

	<refmeta>
	  <refentrytitle>unicode_bidi</refentrytitle>
	  <manvolnum>3</manvolnum>
	</refmeta>

	<refnamediv>
	  <refname>unicode_bidi</refname>
	  <refname>unicode_bidi_calc</refname>
	  <refname>unicode_bidi_reorder</refname>
	  <refname>unicode_bidi_mirror</refname>
	  <refname>unicode_bidi_bracket_type</refname>

	  <refpurpose>unicode bidirectional algorithm</refpurpose>
	</refnamediv>

	<refsynopsisdiv>
	  <funcsynopsis>
	    <funcsynopsisinfo>#include &lt;courier-unicode.h&gt;</funcsynopsisinfo>
	    <funcsynopsisinfo>unicode_bidi_level_t lr=UNICODE_BIDI_LR;</funcsynopsisinfo>
	    <funcprototype>
	      <funcdef>void <function>unicode_bidi_calc</function></funcdef>
              <paramdef>const char32_t *<parameter>p</parameter></paramdef>
              <paramdef>size_t <parameter>n</parameter></paramdef>
              <paramdef>unicode_bidi_level_t *<parameter>levels</parameter></paramdef>
              <paramdef>const unicode_bidi_level_t *<parameter>initial_embedding_level</parameter></paramdef>
	    </funcprototype>

	    <funcprototype>
	      <funcdef>void <function>unicode_bidi_reorder</function></funcdef>
              <paramdef>char32_t *<parameter>string</parameter></paramdef>
              <paramdef>unicode_bidi_level_t *<parameter>levels</parameter></paramdef>
              <paramdef>size_t <parameter>n</parameter></paramdef>
              <paramdef>void (*<parameter>reorder_callback</parameter>)(size_t, size_t, void *)</paramdef>
	      <paramdef>void *<parameter>arg</parameter></paramdef>
	    </funcprototype>

	    <funcprototype>
	      <funcdef>char32_t <function>bidi_mirror</function></funcdef>
              <paramdef>char32_t <parameter>c</parameter></paramdef>
	    </funcprototype>

	    <funcprototype>
	      <funcdef>char32_t <function>bidi_bracket_type</function></funcdef>
              <paramdef>char32_t <parameter>c</parameter></paramdef>
              <paramdef>unicode_bracket_type_t *<parameter>ret</parameter></paramdef>
	    </funcprototype>

	    <funcprototype>
	      <funcdef>enum_bidi_type_t <function>unicode_bidi_type</function></funcdef>
              <paramdef>char32_t <parameter>c</parameter></paramdef>
	    </funcprototype>
	  </funcsynopsis>
	</refsynopsisdiv>
	<refsect1>
	  <title>DESCRIPTION</title>

	  <para>
	    <function>unicode_bidi_calc</function>() and
	    <function>unicode_bidi_reorder</function>() implement
	    the
	    <ulink url="https://www.unicode.org/reports/tr9/tr9-&tr9ver;.html"> Unicode Bi-Directional algorithm</ulink>.
	  </para>
	  <para>
	    The first two parameters to
	    <function>unicode_bidi_calc</function>() are a unicode string
	    and the number of characters in the Unicode string.
	    <parameter>levels</parameter> points to a buffer of
	    <classname>unicode_bidi_level_t</classname> values.
	    The caller is responsible for allocating and deallocating this
	    buffer, of
	    size <parameter>n</parameter>,
	    the same number of values as the number of characters in the
	    Unicode string.
	  </para>
	  <para>
	    <function>unicode_bidi_calc</function>() calculates the
	    embedding level of each character and fills in the
	    <parameter>levels</parameter> buffer (executes all steps of the
	    bidirectional algorithm up to, and including, step L1).
	    A <literal>NULL</literal> <parameter>initial_embedding</parameter>
	    value calculates the default paragraph embedding value.
	    A pointer to a <literal>UNICODE_BIDI_LR</literal> or
	    <literal>UNICODE_BIDI_RL</literal> value explicitly sets a
	    left-to-right or right-to-left paragraph embedding value.
	  </para>

	  <para>
	    <function>unicode_bidi_calc</function>() calculates each
	    character's directional embedding value: an even value for
	    left-to-right text or an odd value for right-to-left text.
	    Unicode characters with an unspecified directional embedding
	    value are specified by the
	    <classname>UNICODE_BIDI_SKIP</classname> embedding level value.
	    This indicates embedding and override markers, which can be
	    removed from the string (together with this embedding value)
	    from the string and the embedding value itself). This can be
	    done before or after <function>unicode_bidi_reorder</function>().
	  </para>

	  <refsect2>
	    <title>Reordering text</title>

	    <para>
	      <function>unicode_bidi_reorder</function> takes the actual
	      unicode string together with the embedding values from
	      <function>unicode_bidi_calc</function>, then reverses the
	      bidirectional string, as specified by step L2 of the bidirectional
	      algorithm.
	    </para>

	    <para>
	      A non-<literal>NULL</literal>
	      <parameter>reorder_callback</parameter> gets invoked to report
	      each reversed character range. The callback's first parameter
	      is the index of the first reversed character, the second parameter
	      is the number of reversed characters, starting at the given
	      index of the Unicode string.
	      The third parameter is the <parameter>arg</parameter> passthrough
	      parameter.
	    </para>

	    <para>
	      <function>unicode_bidi_reorder</function> modifies its
	      <parameter>string</parameter> and <parameter>levels</parameter>.
	      <parameter>reorder_callback</parameter> gets invoked after
	      reversing each consecutive range of values in the
	      <parameter>string</parameter> and <parameter>levels</parameter>
	      buffers. For example: <quote>reorder_callback(5, 7, arg)</quote>
	      reports that character indexes #5 through #11 got reversed.
	    </para>

	    <para>
	      A NULL <parameter>string</parameter> pointer leaves the
	      <parameter>levels</parameter> buffer unchanged, but still
	      invokes the <parameter>reorder_callback</parameter> as if
	      the character string, and their embedding values, were reversed.
	    </para>
	  </refsect2>
	  <refsect2>
	    <title>Miscellaneous utility functions</title>

	    <para>
	      <function>unicode_bidi_type</function>
	      looks up each character's bidirectional character type.
	    </para>
	    <para>
	      <function>unicode_bidi_mirror</function>
	      returns the glyph that's a mirror image of the parameter
	      (i.e. an open parenthesis for a close parenthesis, and vice
	      versa); or the same value if there is no mirror image
	      (this is the <literal>Bidi_Mirrored=Yes</literal> property).
	    </para>

	    <para>
	      <function>unicode_bidi_bracket_type</function>
	      looks up each bracket character and returns its opposite, or
	      the same value if the character is not a bracket that has an
	      opposing bracket character
	      (this is the <literal>Bidi_Paired_Bracket_type</literal>
	      property).
	      A non-NULL <parameter>ret</parameter> gets initialized to
	      either <literal>UNICODE_BIDI_o</literal>,
	      <literal>UNICODE_BIDI_c</literal> or
	      <literal>UNICODE_BIDI_n</literal>.
	    </para>
	  </refsect2>
	</refsect1>
	<refsect1>
	  <title>SEE ALSO</title>
	  <para>
	    <ulink url="https://www.unicode.org/reports/tr9/tr9-&tr9ver;.html">TR-9</ulink>,
	    <link linkend="unicode__bidi">
	      <citerefentry><refentrytitle>unicode::bidi</refentrytitle>
	      <manvolnum>3</manvolnum></citerefentry></link>,
	    <link linkend="courier-unicode">
	      <citerefentry>
		<refentrytitle>courier-unicode</refentrytitle>
		<manvolnum>7</manvolnum></citerefentry></link>,
	  </para>
	</refsect1>
      </refentry>

      <refentry id="unicode_category_lookup">
	<refentryinfo><author><firstname>Sam</firstname><surname>Varshavchik</surname><contrib>Author</contrib></author><productname>Courier Unicode Library</productname></refentryinfo>

	<refmeta>
	  <refentrytitle>unicode_category_lookup</refentrytitle>
	  <manvolnum>3</manvolnum>
	</refmeta>

	<refnamediv>
	  <refname>unicode_category_lookup</refname>
	  <refname>unicode_isalnum</refname>
	  <refname>unicode_isalpha</refname>
	  <refname>unicode_isblank</refname>
	  <refname>unicode_isdigit</refname>
	  <refname>unicode_isgraph</refname>
	  <refname>unicode_islower</refname>
	  <refname>unicode_ispunct</refname>
	  <refname>unicode_isspace</refname>
	  <refname>unicode_isupper</refname>

	  <refpurpose>unicode character categorization</refpurpose>
	</refnamediv>

	<refsynopsisdiv>
	  <funcsynopsis>
	    <funcsynopsisinfo>#include &lt;courier-unicode.h&gt;</funcsynopsisinfo>
	    <funcprototype>
	      <funcdef>uint32_t <function>unicode_category_lookup</function></funcdef>
              <paramdef>char32_t <parameter>c</parameter></paramdef>
	    </funcprototype>

	    <funcprototype>
              <funcdef>int <function>unicode_isalnum</function></funcdef>
              <paramdef>char32_t <parameter>c</parameter></paramdef>
	    </funcprototype>

	    <funcprototype>
              <funcdef>int <function>unicode_isalpha</function></funcdef>
              <paramdef>char32_t <parameter>c</parameter></paramdef>
	    </funcprototype>

	    <funcprototype>
              <funcdef>int <function>unicode_isblank</function></funcdef>
              <paramdef>char32_t <parameter>c</parameter></paramdef>
	    </funcprototype>

	    <funcprototype>
              <funcdef>int <function>unicode_isdigit</function></funcdef>
              <paramdef>char32_t <parameter>c</parameter></paramdef>
	    </funcprototype>

	    <funcprototype>
              <funcdef>int <function>unicode_isgraph</function></funcdef>
              <paramdef>char32_t <parameter>c</parameter></paramdef>
	    </funcprototype>

	    <funcprototype>
              <funcdef>int <function>unicode_islower</function></funcdef>
              <paramdef>char32_t <parameter>c</parameter></paramdef>
	    </funcprototype>

	    <funcprototype>
              <funcdef>int <function>unicode_ispunct</function></funcdef>
              <paramdef>char32_t <parameter>c</parameter></paramdef>
	    </funcprototype>

	    <funcprototype>
              <funcdef>int <function>unicode_isspace</function></funcdef>
              <paramdef>char32_t <parameter>c</parameter></paramdef>
	    </funcprototype>

	    <funcprototype>
              <funcdef>int <function>unicode_isupper</function></funcdef>
              <paramdef>char32_t <parameter>c</parameter></paramdef>
	    </funcprototype>
	  </funcsynopsis>
	</refsynopsisdiv>
	<refsect1>
	  <title>DESCRIPTION</title>

	  <para>
	    <function>unicode_category_lookup</function>() looks up the
	    <ulink url="https://unicode.org/notes/tn36/">unicode character's
	    categorization</ulink>.
	    <function>unicode_category_lookup</function>() returns a 32 bit
	    value.
	    The value's
	    <symbol>UNICODE_CATEGORY_1</symbol> bits specify the first level
	    of the unicode character's category, with
	    <symbol>UNICODE_CATEGORY_2</symbol>,
	    <symbol>UNICODE_CATEGORY_3</symbol>, and
	    <symbol>UNICODE_CATEGORY_4</symbol> bits specifying the 2nd,
	    3rd, and 4th level, if given. A value of 0 for each corresponding
	    bit set indicates that no category is specified for this level,
	    for this character; otherwise the possible values are defined
	    in <filename>&lt;courier-unicode.h&gt;</filename>.
	  </para>

	  <para>
	    The remaining functions implement comparable equivalents of
	    their non-unicode versions in the standard C library, as follows:
	  </para>

	  <variablelist>
	    <varlistentry>
              <term><function>unicode_isalnum</function>()</term>
	      <listitem>
		<para>
		  Returns non-0 for all
		  <function>unicode_isalpha</function>() or
		  <function>unicode_isdigit</function>().
		</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
              <term><function>unicode_isalpha</function>()</term>
	      <listitem>
		<para>
		  Returns non-0 for all
		  <symbol>UNICODE_CATEGORY_1_LETTER</symbol>.
		</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
              <term><function>unicode_isblank</function>()</term>
	      <listitem>
		<para>
		  Return non-0 for
		  <symbol>TAB</symbol>, and all
		  <symbol>UNICODE_CATEGORY_2_SPACE</symbol>.
		</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
              <term><function>unicode_isdigit</function>()</term>
	      <listitem>
		<para>
		  Returns non-0 for all
		  <symbol>UNICODE_CATEGORY_1_NUMBER</symbol>
		  | <symbol>UNICODE_CATEGORY_2_DIGIT</symbol>,
		  only (no third categories).
		</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
              <term><function>unicode_isgraph</function>()</term>
	      <listitem>
		<para>
		  Returns non-0 for all codepoints above
		  <symbol>SPACE</symbol> which are not
		  <function>unicode_isspace</function>().
		</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
              <term><function>unicode_islower</function>()</term>
	      <listitem>
		<para>
		  Returns non-0 for all
		  <function>unicode_isalpha</function>() for which the
		  character is
		  equal to
		  <link linkend="unicode_uc">
		    <citerefentry><refentrytitle>unicode_lc</refentrytitle>
		  <manvolnum>3</manvolnum></citerefentry></link>
		  of itself.
		</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
              <term><function>unicode_ispunct</function>()</term>
	      <listitem>
		<para>
		  Returns non-0 for all
		  <symbol>UNICODE_CATEGORY_1_PUNCTUATION</symbol>.
		</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
              <term><function>unicode_isspace</function>()</term>
	      <listitem>
		<para>
		  Returns non-0 for unicode_isblank() or
		  for unicode characters
		  with linebreaking properties of
		  <symbol>BK</symbol>,
		  <symbol>CR</symbol>,
		  <symbol>LF</symbol>,
		  <symbol>NL</symbol>,
		  and
		  <symbol>SP</symbol>.
		</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
              <term><function>unicode_isupper</function>()</term>
	      <listitem>
		<para>
		  Returns non-0 for all
		  <function>unicode_isalpha</function>() for which the
		  character is
		  equal to
		  <link linkend="unicode_uc">
		    <citerefentry><refentrytitle>unicode_uc</refentrytitle>
		  <manvolnum>3</manvolnum></citerefentry></link>
		  of itself.
		</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</refsect1>
	<refsect1>
	  <title>SEE ALSO</title>
	  <para>
	    <link linkend="courier-unicode">
	      <citerefentry>
		<refentrytitle>courier-unicode</refentrytitle>
		<manvolnum>7</manvolnum></citerefentry></link>,
	    <link linkend="unicode_uc">
	      <citerefentry><refentrytitle>unicode_convert_tocase</refentrytitle>
	      <manvolnum>3</manvolnum></citerefentry></link>.
	  </para>
	</refsect1>
      </refentry>

      <refentry id="unicode_convert">
	<refentryinfo><author><firstname>Sam</firstname><surname>Varshavchik</surname><contrib>Author</contrib></author><productname>Courier Unicode Library</productname></refentryinfo>

	<refmeta>
	  <refentrytitle>unicode_convert</refentrytitle>
	  <manvolnum>3</manvolnum>
	</refmeta>

	<refnamediv>
	  <refname>unicode_u_ucs4_native</refname>
	  <refname>unicode_u_ucs2_native</refname>
	  <refname>unicode_convert_init</refname>
	  <refname>unicode_convert</refname>
	  <refname>unicode_convert_deinit</refname>

          <refname>unicode_convert_tocbuf_init</refname>
	  <refname>unicode_convert_tou_init</refname>
	  <refname>unicode_convert_fromu_init</refname>
	  <refname>unicode_convert_uc</refname>

	  <refname>unicode_convert_tocbuf_toutf8_init</refname>
	  <refname>unicode_convert_tocbuf_fromutf8_init</refname>

	  <refname>unicode_convert_toutf8</refname>
	  <refname>unicode_convert_fromutf8</refname>
	  <refname>unicode_convert_tobuf</refname>
	  <refname>unicode_convert_tou_tobuf</refname>
	  <refname>unicode_convert_fromu_tobuf</refname>

	  <refpurpose>unicode character set conversion</refpurpose>
	</refnamediv>

	<refsynopsisdiv>
	  <funcsynopsis>
	    <funcsynopsisinfo>#include &lt;courier-unicode.h&gt;

	    extern const char unicode_u_ucs4_native[];

	    extern const char unicode_u_ucs2_native[];</funcsynopsisinfo>
	    <funcprototype>
              <funcdef>unicode_convert_handle_t <function>unicode_convert_init</function></funcdef>
              <paramdef>const char *<parameter>src_chset</parameter></paramdef>
              <paramdef>const char *<parameter>dst_chset</parameter></paramdef>
              <paramdef>void *<parameter>cb_arg</parameter></paramdef>
	    </funcprototype>

	    <funcprototype>
              <funcdef>int <function>unicode_convert</function></funcdef>
              <paramdef>unicode_convert_handle_t <parameter>handle</parameter></paramdef>
              <paramdef>const char *<parameter>text</parameter></paramdef>
              <paramdef>size_t <parameter>cnt</parameter></paramdef>
	    </funcprototype>

	    <funcprototype>
              <funcdef>int <function>unicode_convert_deinit</function></funcdef>
              <paramdef>unicode_convert_handle_t <parameter>handle</parameter></paramdef>
              <paramdef>int *<parameter>errptr</parameter></paramdef>
	    </funcprototype>

	    <funcprototype>
              <funcdef>unicode_convert_handle_t <function>unicode_convert_tocbuf_init</function></funcdef>
              <paramdef>const char *<parameter>src_chset</parameter></paramdef>
              <paramdef>const char *<parameter>dst_chset</parameter></paramdef>
	      <paramdef>char **<parameter>cbufptr_ret</parameter></paramdef>
	      <paramdef>size_t *<parameter>cbufsize_ret</parameter></paramdef>
              <paramdef>int <parameter>nullterminate</parameter></paramdef>
	    </funcprototype>

	    <funcprototype>
              <funcdef>unicode_convert_handle_t <function>unicode_convert_tocbuf_toutf8_init</function></funcdef>
              <paramdef>const char *<parameter>src_chset</parameter></paramdef>
	      <paramdef>char **<parameter>cbufptr_ret</parameter></paramdef>
	      <paramdef>size_t *<parameter>cbufsize_ret</parameter></paramdef>
              <paramdef>int <parameter>nullterminate</parameter></paramdef>
	    </funcprototype>

	    <funcprototype>
              <funcdef>unicode_convert_handle_t <function>unicode_convert_tocbuf_fromutf8_init</function></funcdef>
              <paramdef>const char *<parameter>dst_chset</parameter></paramdef>
	      <paramdef>char **<parameter>cbufptr_ret</parameter></paramdef>
	      <paramdef>size_t *<parameter>cbufsize_ret</parameter></paramdef>
              <paramdef>int <parameter>nullterminate</parameter></paramdef>
	    </funcprototype>

	    <funcprototype>
              <funcdef>unicode_convert_handle_t <function>unicode_convert_tou_init</function></funcdef>
              <paramdef>const char *<parameter>src_chset</parameter></paramdef>
	      <paramdef>char32_t **<parameter>ucptr_ret</parameter></paramdef>
	      <paramdef>size_t *<parameter>ucsize_ret</parameter></paramdef>
              <paramdef>int <parameter>nullterminate</parameter></paramdef>
	    </funcprototype>

	    <funcprototype>
              <funcdef>unicode_convert_handle_t <function>unicode_convert_fromu_init</function></funcdef>
              <paramdef>const char *<parameter>dst_chset</parameter></paramdef>
	      <paramdef>char **<parameter>cbufptr_ret</parameter></paramdef>
	      <paramdef>size_t *<parameter>cbufsize_ret</parameter></paramdef>
              <paramdef>int <parameter>nullterminate</parameter></paramdef>
	    </funcprototype>

	    <funcprototype>
              <funcdef>int <function>unicode_convert_uc</function></funcdef>
              <paramdef>unicode_convert_handle_t <parameter>handle</parameter></paramdef>
              <paramdef>const char32_t *<parameter>text</parameter></paramdef>
	      <paramdef>size_t <parameter>cnt</parameter></paramdef>
	    </funcprototype>

	    <funcprototype>
              <funcdef>char *<function>unicode_convert_toutf8</function></funcdef>
              <paramdef>const char *<parameter>text</parameter></paramdef>
              <paramdef>const char *<parameter>charset</parameter></paramdef>
	      <paramdef>int *<parameter>error</parameter></paramdef>
	    </funcprototype>

	    <funcprototype>
              <funcdef>char *<function>unicode_convert_fromutf8</function></funcdef>
              <paramdef>const char *<parameter>text</parameter></paramdef>
              <paramdef>const char *<parameter>charset</parameter></paramdef>
	      <paramdef>int *<parameter>error</parameter></paramdef>
	    </funcprototype>

	    <funcprototype>
              <funcdef>char *<function>unicode_convert_tobuf</function></funcdef>
              <paramdef>const char *<parameter>text</parameter></paramdef>
              <paramdef>const char *<parameter>charset</parameter></paramdef>
              <paramdef>const char *<parameter>dstcharset</parameter></paramdef>
	      <paramdef>int *<parameter>error</parameter></paramdef>
	    </funcprototype>

	    <funcprototype>
              <funcdef>int <function>unicode_convert_toubuf</function></funcdef>
              <paramdef>const char *<parameter>text</parameter></paramdef>
	      <paramdef>size_t <parameter>text_l</parameter></paramdef>
              <paramdef>const char *<parameter>charset</parameter></paramdef>
              <paramdef>char32_t **<parameter>uc</parameter></paramdef>
	      <paramdef>size_t *<parameter>ucsize</parameter></paramdef>
	      <paramdef>int *<parameter>error</parameter></paramdef>
	    </funcprototype>

	    <funcprototype>
              <funcdef>int <function>unicode_convert_fromu_tobuf</function></funcdef>
              <paramdef>const char32_t *<parameter>utext</parameter></paramdef>
	      <paramdef>size_t <parameter>utext_l</parameter></paramdef>
              <paramdef>const char *<parameter>charset</parameter></paramdef>
              <paramdef>char **<parameter>c</parameter></paramdef>
	      <paramdef>size_t *<parameter>csize</parameter></paramdef>
	      <paramdef>int *<parameter>error</parameter></paramdef>
	    </funcprototype>

	  </funcsynopsis>

	</refsynopsisdiv>

	<refsect1>
	  <title>DESCRIPTION</title>

	  <para>
	    <varname>unicode_u_ucs4_native</varname>[] contains the
	    string <quote>UCS-4BE</quote> or <quote>UCS-4LE</quote>,
	    matching the native <classname>char32_t</classname> endianness.
	  </para>

	  <para>
	    <varname>unicode_u_ucs2_native</varname>[] contains the
	    string <quote>UCS-2BE</quote> or <quote>UCS-2LE</quote>,
	    matching the native <classname>char32_t</classname> endianness.
	  </para>

	  <para>
	    <function>unicode_convert_init</function>(),
	    <function>unicode_convert</function>(), and
	    <function>unicode_convert_deinit</function>() are an adaption of th
	    <ulink url="https://manpages.courier-mta.org/htmlman3/iconv.3.html">
	      <citerefentry><refentrytitle>iconv</refentrytitle>
	      <manvolnum>3</manvolnum></citerefentry></ulink> API that uses the same
	      calling convention as the other algorithms in this unicode library,
	      with some value-added features.
	      These functions use
	      <citerefentry><refentrytitle>iconv</refentrytitle>
	      <manvolnum>3</manvolnum></citerefentry> to effect the actual
	      character set conversion.
	  </para>

	  <para>
	    <function>unicode_convert_init</function>() returns a non-NULL handle
	    for the requested conversion, or NULL if the requested conversion is
	    not available.

	    <function>unicode_convert_init</function>() takes a pointer to
	    the output function that receives receives converted character text.
	    The output function receives a pointer to the converted character
	    text, and the number of characters in the converted text.
	    The output function gets repeatedly called, until it receives
	    the entire converted text.
	  </para>

	  <para>
	    The character text to convert gets passed, repeatedly, to
	    <function>unicode_convert</function>().
	    Each call to <function>unicode_convert</function>() results in
	    the output function getting invoked, zero or more times, with each
	    successive part of the
	    converted text. Finally,
	    <function>unicode_convert_deinit</function>() stops the conversion
	    and deallocates the conversion handle.
	  </para>

	  <para>
	    It's possible that a call to
	    <function>unicode_convert_deinit</function>() results in some
	    additional calls to the output function, passing the remaining,
	    final parts, of the converted text, before
	    <function>unicode_convert_deinit</function>() deallocates the
	    handle, and returns.
	  </para>

	  <para>
	    The output function should return 0 normally. A non-0 return
	    indicates n error condition.
	    <function>unicode_convert_deinit</function>() returns
	    non-zero if any previous invocation of the output function returned
	    non-zero (this includes any invocations of the output function
	    resulting from this call, or prior
	    <function>unicode_convert</function>() calls), or 0 if all
	    invocations of the output function returned 0.
	  </para>

	  <para>
	    If the <parameter>errptr</parameter> is not <literal>NULL</literal>,
	    *<parameter>errptr</parameter> gets set to non-zero if there were
	    any conversion errors -- if there was any text that could not be
	    converted to the destination character text.
	  </para>

	  <para>
	    <function>unicode_convert</function>() also returns non-zero if
	    it calls the output function and it returns non-zero, however
	    the conversion handle remains allocated, so
	    <function>unicode_convert_deinit</function>() must still be called,
	    to clean that up.
	  </para>


	  <refsect2>
	    <title>Collecting converted text into a buffer</title>

	    <para>
	      Call
	      <function>unicode_convert_tocbuf_init</function>()
	      instead of
	      <function>unicode_convert_init</function>(), then call
	      <function>unicode_convert</function>()
	      and
	      <function>unicode_convert_deinit</function>() normally.

	      The parameters to
	      <function>unicode_convert_init</function>() specify the source
	      and the destination character sets.

	      <function>unicode_convert_tocbuf_toutf8_init</function>() is
	      just an alias that specifies <literal>UTF-8</literal> as the
	      destination character set.

	      <function>unicode_convert_tocbuf_fromutf8_init</function>() is
	      just an alias that specifies <literal>UTF-8</literal> as the
	      source character st.

	    </para>

	    <para>
	      These functions
	      supply an output function that collects the converted text into
	      a malloc()ed buffer.

	      If <function>unicode_convert_deinit</function>() returns 0,
	      *<parameter>cbufptr_ret</parameter> gets initialized to a
	      malloc()ed buffer, and the number of converted characters,
	      the size of the
	      malloc()ed buffer, get placed into
	      *<parameter>cbufsize_ret</parameter>.
	    </para>

	    <note>
	      <para>
		If the converted string is an empty string,
		*<parameter>cbufsize_ret</parameter>
		gets set to 0,
		but
		*<parameter>cbufptr_ret</parameter>
		still gets initialized (to a dummy malloced buffer).
	      </para>
	    </note>

	    <para>
	      A non-zero <parameter>nullterminate</parameter> places a trailing \0
	      character after the converted string (this is included in
	      *<parameter>cbufsize_ret</parameter>).
	    </para>
	  </refsect2>

	  <refsect2>
	    <title>Converting between character sets and unicode</title>

	    <para>
	      <function>unicode_convert_tou_init</function>()
	      converts character text into a <classname>char32_t</classname>
	      buffer.
	      It works just like
	      <function>unicode_convert_tocbuf_init</function>(), except
	      that only the source character set gets specified and the output
	      buffer is a <classname>char32_t</classname> buffer.
	      <parameter>nullterminate</parameter> terminates the converted
	      unicode characters with a <literal>U+0000</literal>.
	    </para>

	    <para>
	      <function>unicode_convert_fromu_init</function>()
	      converts <classname>char32_t</classname>s to the output
	      character set, and also works like
	      <function>unicode_convert_tocbuf_init</function>().
	      Additionally, in this case,
	      <function>unicode_convert_uc</function>() works just like
	      <function>unicode_convert</function>() except that the
	      input sequence is a
	      <classname>char32_t</classname> sequence, and the
	      count parameter is th enumber of unicode characters.
	    </para>
	  </refsect2>

	  <refsect2>
	    <title>One-shot conversions</title>

	    <para>
	      <function>unicode_convert_toutf8</function>()
	      converts the specified text in the specified text into a UTF-8
	      string, returning a malloced buffer.
	      If <parameter>error</parameter> is
	      not <literal>NULL</literal>, even if
	      <function>unicode_convert_toutf8</function>()
	      returns a non <literal>NULL</literal> value
	      *<parameter>error</parameter> gets set to a non-zero value if
	      a character conversion error has occured, and some characters
	      could not be converted.
	    </para>

	    <para>
	      <function>unicode_convert_fromutf8</function>() does a similar
	      conversion from UTF-8 <parameter>text</parameter> to the specified
	      character set.
	    </para>

	    <para>
	      <function>unicode_convert_tobuf</function>() does a similar
	      conversion between two different character sets.
	    </para>

	    <para>
	      <function>unicode_convert_tou_tobuf</function>() calls
	      <function>unicode_convert_tou_init</function>(), feeds the
	      character string through <function>unicode_convert</function>(),
	      then calls <function>unicode_convert_deinit</function>().
	      If this function returns 0,
	      *<parameter>uc</parameter> and *<parameter>ucsize</parameter>
	      are set to a malloced buffer+size holding the unicode char array.
	    </para>

	    <para>
	      <function>unicode_convert_fromu_tobuf</function>() calls
	      <function>unicode_convert_fromu_init</function>(), feeds the
	      unicode array through <function>unicode_convert_uc</function>(),
	      then calls unicode_convert_deinit().

	      If this function returns 0,
	      *<parameter>c</parameter> and *<parameter>csize</parameter>
	      are set to a malloced buffer+size holding the char array.
	    </para>
	  </refsect2>
	</refsect1>
	<refsect1>
	  <title>SEE ALSO</title>
	  <para>
	    <link linkend="courier-unicode">
	      <citerefentry>
		<refentrytitle>courier-unicode</refentrytitle>
		<manvolnum>7</manvolnum></citerefentry></link>,
	    <link linkend="unicode_uc">
	      <citerefentry><refentrytitle>unicode_convert_tocase</refentrytitle>
	      <manvolnum>3</manvolnum></citerefentry></link>,
	      <link linkend="unicode_default_chset">
		<citerefentry><refentrytitle>unicode_default_chset</refentrytitle>
		<manvolnum>3</manvolnum></citerefentry></link>.
	  </para>
	</refsect1>
      </refentry>

      <refentry id="unicode_default_chset">
	<refentryinfo><author><firstname>Sam</firstname><surname>Varshavchik</surname><contrib>Author</contrib></author><productname>Courier Unicode Library</productname></refentryinfo>

	<refmeta>
	  <refentrytitle>unicode_default_chset</refentrytitle>
	  <manvolnum>3</manvolnum>
	</refmeta>

	<refnamediv>
	  <refname>unicode_default_chset</refname>
	  <refname>unicode_locale_chset</refname>
	  <refpurpose>return the system character set name</refpurpose>
	</refnamediv>

	<refsynopsisdiv>
	  <funcsynopsis>
	    <funcsynopsisinfo>#include &lt;courier-unicode.h&gt;</funcsynopsisinfo>
	    <funcprototype>
              <funcdef>const char *<function>unicode_default_chset</function></funcdef>
	      <void />
	    </funcprototype>

	    <funcprototype>
              <funcdef>const char *<function>unicode_locale_chset</function></funcdef>
	      <void />
	    </funcprototype>
	  </funcsynopsis>
	</refsynopsisdiv>
	<refsect1>
	  <title>DESCRIPTION</title>
	  <para>
	    <function>unicode_default_chset</function>() returns the name of the
	    system environment character set (usually
	    <quote>nl_langinfo(CODESET)</quote>, or from some suitable environment
	    variable).
	    <function>unicode_locale_chset</function>() returns the name of the
	    current application locale's character set.
	  </para>
	</refsect1>
	<refsect1>
	  <title>SEE ALSO</title>
	  <para>
	    <link linkend="courier-unicode">
	      <citerefentry>
		<refentrytitle>courier-unicode</refentrytitle>
		<manvolnum>7</manvolnum></citerefentry></link>,
	    <link linkend="unicode_uc">
	      <citerefentry><refentrytitle>unicode_convert_tocase</refentrytitle>
	      <manvolnum>3</manvolnum></citerefentry></link>.
	  </para>
	</refsect1>
      </refentry>

      <refentry id="unicode_emoji_lookup">
	<refentryinfo><author><firstname>Sam</firstname><surname>Varshavchik</surname><contrib>Author</contrib></author><productname>Courier Unicode Library</productname></refentryinfo>

	<refmeta>
	  <refentrytitle>unicode_emoji_lookup</refentrytitle>
	  <manvolnum>3</manvolnum>
	</refmeta>

	<refnamediv>
	  <refname>unicode_emoji_lookup</refname>
          <refname>unicode_emoji</refname>
          <refname>unicode_emoji_presentation</refname>
	  <refname>unicode_emoji_modifier</refname>
	  <refname>unicode_emoji_modifier_base</refname>
	  <refname>unicode_emoji_component</refname>
	  <refname>unicode_emoji_extended_pictographic</refname>

	  <refpurpose>look up unicode character's Unicode Emoji Classification</refpurpose>
	</refnamediv>

	<refsynopsisdiv>
	  <funcsynopsis>
	    <funcsynopsisinfo>#include &lt;courier-unicode.h&gt;</funcsynopsisinfo>
	    <funcprototype>
              <funcdef>unicode_emoji_t <function>unicode_emoji_lookup</function></funcdef>
              <paramdef>char32_t <parameter>c</parameter></paramdef>
	    </funcprototype>
	  </funcsynopsis>

	  <funcsynopsis>
	    <funcprototype>
              <funcdef>int <function>unicode_emoji</function></funcdef>
              <paramdef>char32_t <parameter>c</parameter></paramdef>
	    </funcprototype>
	  </funcsynopsis>

	  <funcsynopsis>
	    <funcprototype>
              <funcdef>int <function>unicode_emoji_presentation</function></funcdef>
              <paramdef>char32_t <parameter>c</parameter></paramdef>
	    </funcprototype>
	  </funcsynopsis>

	  <funcsynopsis>
	    <funcprototype>
              <funcdef>int <function>unicode_emoji_modifier</function></funcdef>
              <paramdef>char32_t <parameter>c</parameter></paramdef>
	    </funcprototype>
	  </funcsynopsis>

	  <funcsynopsis>
	    <funcprototype>
              <funcdef>int <function>unicode_emoji_modifier_base</function></funcdef>
              <paramdef>char32_t <parameter>c</parameter></paramdef>
	    </funcprototype>
	  </funcsynopsis>

	  <funcsynopsis>
	    <funcprototype>
              <funcdef>int <function>unicode_emoji_component</function></funcdef>
              <paramdef>char32_t <parameter>c</parameter></paramdef>
	    </funcprototype>
	  </funcsynopsis>

	  <funcsynopsis>
	    <funcprototype>
              <funcdef>int <function>unicode_emoji_extended_pictographic</function></funcdef>
              <paramdef>char32_t <parameter>c</parameter></paramdef>
	    </funcprototype>
	  </funcsynopsis>
	</refsynopsisdiv>
	<refsect1>
	  <title>DESCRIPTION</title>
	  <para>
	    <function>unicode_emoji_lookup</function>() returns the
	    unicode emoji properties of the specified character, as a bitmask
	    of <literal>UNICODE_EMOJI</literal> flags, as defined in the
	    header file.
	    <function>unicode_emoji</function>(),
	    <function>unicode_emoji_presentation</function>(),
	    <function>unicode_emoji_modifier</function>(),
	    <function>unicode_emoji_modifier_base</function>(),
	    <function>unicode_emoji_component</function>(), and
	    <function>unicode_emoji_extended_pictographic</function>()
	    check whether the given character carries a specific emoji
	    property. They return 0 if not, and non-0 if the specified
	    character has the corresponding property.
	  </para>
        </refsect1>
	<refsect1>
	  <title>SEE ALSO</title>
	  <para>
	    <ulink url="https://www.unicode.org/reports/tr51/tr51-&tr51ver;.html">TR-51</ulink>,
	    <link linkend="courier-unicode">
	      <citerefentry>
		<refentrytitle>courier-unicode</refentrytitle>
		<manvolnum>7</manvolnum></citerefentry></link>.
	  </para>
	</refsect1>
      </refentry>

      <refentry id="unicode_html40ent_lookup">
	<refentryinfo><author><firstname>Sam</firstname><surname>Varshavchik</surname><contrib>Author</contrib></author><productname>Courier Unicode Library</productname></refentryinfo>

	<refmeta>
	  <refentrytitle>unicode_html40ent_lookup</refentrytitle>
	  <manvolnum>3</manvolnum>
	</refmeta>

	<refnamediv>
	  <refname>unicode_html40ent_lookup</refname>
	  <refpurpose>look up unicode character for an HTML 4.0 entity</refpurpose>
	</refnamediv>

	<refsynopsisdiv>
	  <funcsynopsis>
	    <funcsynopsisinfo>#include &lt;courier-unicode.h&gt;</funcsynopsisinfo>
	    <funcprototype>
              <funcdef>char32_t <function>unicode_html40ent_lookup</function></funcdef>
              <paramdef>const char *<parameter>entity</parameter></paramdef>
	    </funcprototype>
	  </funcsynopsis>
	</refsynopsisdiv>
	<refsect1>
	  <title>DESCRIPTION</title>
	  <para>
	    <function>unicode_html40ent_lookup</function>() returns the
	    unicode character represented by an HTML 4.0 entity. The
	    <parameter>entity</parameter> is a string, such as
	    <quote>quot</quote>, in which case
	    <function>unicode_html40ent_lookup</function>() returns 34.
	  </para>

	  <para>
	    Additionally,
	    <function>unicode_html40ent_lookup</function>() parses
	    a numerical entity given as
	    <quote>#<replaceable>decimal</replaceable></quote> or
	    <quote>#x<replaceable>hex</replaceable></quote>.
	  </para>

	  <para>
	    <function>unicode_html40ent_lookup</function>() returns 0 if the
	    <parameter>entity</parameter> is not a known entity that represents
	    a single unicode character.
	  </para>
	</refsect1>
	<refsect1>
	  <title>SEE ALSO</title>
	  <para>
	    <link linkend="courier-unicode">
	      <citerefentry>
		<refentrytitle>courier-unicode</refentrytitle>
		<manvolnum>7</manvolnum></citerefentry></link>,
	    <link linkend="unicode_uc">
	      <citerefentry><refentrytitle>unicode_convert_tocase</refentrytitle>
	      <manvolnum>3</manvolnum></citerefentry></link>.
	  </para>
	</refsect1>
      </refentry>

      <refentry id="unicode_grapheme_break">
	<refentryinfo><author><firstname>Sam</firstname><surname>Varshavchik</surname><contrib>Author</contrib></author><productname>Courier Unicode Library</productname></refentryinfo>
	<refmeta>
	  <refentrytitle>unicode_grapheme_break</refentrytitle>
	  <manvolnum>3</manvolnum>
	</refmeta>

	<refnamediv>
	  <refname>unicode_grapheme_break</refname>
	  <refname>unicode_grapheme_break_init</refname>
	  <refname>unicode_grapheme_break_next</refname>
	  <refname>unicode_grapheme_break_deinit</refname>
	  <refpurpose>unicode grapheme cluster boundary rules</refpurpose>
	</refnamediv>

	<refsynopsisdiv>
	  <funcsynopsis>
	    <funcsynopsisinfo>#include &lt;courier-unicode.h&gt;</funcsynopsisinfo>

	    <funcprototype>
              <funcdef>unicode_grapheme_break_info_t <function>unicode_grapheme_break_init</function></funcdef>
	      <void />
	    </funcprototype>

	    <funcprototype>
              <funcdef>int <function>unicode_grapheme_next</function></funcdef>
              <paramdef>unicode_grapheme_break_info_t <parameter>handle</parameter></paramdef>
              <paramdef>char32_t <parameter>c</parameter></paramdef>
	    </funcprototype>

	    <funcprototype>
              <funcdef>void <function>unicode_grapheme_deinit</function></funcdef>
              <paramdef>unicode_grapheme_break_info_t <parameter>handle</parameter></paramdef>
	    </funcprototype>

	    <funcprototype>
              <funcdef>int <function>unicode_grapheme_break</function></funcdef>
              <paramdef>char32_t <parameter>a</parameter></paramdef>
              <paramdef>char32_t <parameter>b</parameter></paramdef>
	    </funcprototype>
	  </funcsynopsis>
	</refsynopsisdiv>
	<refsect1>
	  <title>DESCRIPTION</title>

	  <para>
	    These functions implement the unicode grapheme cluster breaking
	    algorithm. Invoke
	    <function>unicode_grapheme_break_init</function>() to initialize
	    the grapheme cluster breaking algorithm.
	    <function>unicode_grapheme_break_init</function>() returns an
	    opaque handle. Each subsequent call to
	    <function>unicode_grapheme_break_next</function>() passes this
	    handle, and the next character.
	    <function>unicode_grapheme_break_next</function>() returns a non-0
	    value if there's a grapheme break before the character, in a
	    sequence of Unicode characters.
	    <function>unicode_grapheme_break_deinit</function>() releases
	    all reosurces used by the grapheme breaking handle, and the
	    <classname>unicode_grapheme_break_info_t</classname> handle
	    is no longer valid after this call.
	  </para>
	  <para>
	    The first call to <function>unicode_grapheme_break_next</function>()
	    always returns non-0, as per the GB1 rule.
	  </para>
	  <para>
	    <function>unicode_grapheme_break</function>() is a simplified
	    interface that returns non-zero
	    if there is a grapheme break between two unicode characters
	    <parameter>a</parameter> and
	    <parameter>b</parameter>.
	    This is is equivalent to calling
	    <function>unicode_grapheme_break_init</function>(),
	    followed by two calls to
	    <function> unicode_grapheme_break_next</function>(), and finally
	    <function>unicode_grapheme_break_deinit</function>(), then
	    returning
	    the result of the second
	    call to <function>unicode_grapheme_break_next</function>().
	  </para>
	</refsect1>

	<refsect1>
	  <title>SEE ALSO</title>

	  <para>
	    <ulink url="https://www.unicode.org/reports/tr29/tr29-&tr29ver;.html">TR-29</ulink>,
	    <link linkend="courier-unicode">
	      <citerefentry>
		<refentrytitle>courier-unicode</refentrytitle>
		<manvolnum>7</manvolnum></citerefentry></link>,
	    <link linkend="unicode_uc">
	      <citerefentry><refentrytitle>unicode_convert_tocase</refentrytitle>
	      <manvolnum>3</manvolnum></citerefentry></link>,
	      <link linkend="unicode_line_break">
		<citerefentry><refentrytitle>unicode_line_break</refentrytitle>
		<manvolnum>3</manvolnum></citerefentry></link>,
		<link linkend="unicode_word_break">
		  <citerefentry><refentrytitle>unicode_word_break</refentrytitle>
		  <manvolnum>3</manvolnum></citerefentry></link>.
	  </para>
	</refsect1>
      </refentry>

      <refentry id="unicode_line_break">
	<refentryinfo><author><firstname>Sam</firstname><surname>Varshavchik</surname><contrib>Author</contrib></author><productname>Courier Unicode Library</productname></refentryinfo>
	<refmeta>
	  <refentrytitle>unicode_line_break</refentrytitle>
	  <manvolnum>3</manvolnum>
	</refmeta>

	<refnamediv>
	  <refname>unicode_line_break</refname>
	  <refname>unicode_lb_init</refname>
	  <refname>unicode_lb_set_opts</refname>
	  <refname>unicode_lb_next</refname>
	  <refname>unicode_lb_next_cnt</refname>
	  <refname>unicode_lb_end</refname>

	  <refname>unicode_lbc_init</refname>
	  <refname>unicode_lbc_set_opts</refname>
	  <refname>unicode_lbc_next</refname>
	  <refname>unicode_lbc_next_cnt</refname>
	  <refname>unicode_lbc_end</refname>
	  <refpurpose>calculate mandatory or allowed line breaks</refpurpose>
	</refnamediv>

	<refsynopsisdiv>
	  <funcsynopsis>
	    <funcsynopsisinfo>#include &lt;courier-unicode.h&gt;</funcsynopsisinfo>
	    <funcprototype>
              <funcdef>unicode_lb_info_t <function>unicode_lb_init</function></funcdef>
              <paramdef>int (*<parameter>cb_func</parameter>)(int, void *)</paramdef>
              <paramdef>void *<parameter>cb_arg</parameter></paramdef>
	    </funcprototype>

	    <funcprototype>
              <funcdef>void <function>unicode_lb_set_opts</function></funcdef>
              <paramdef>unicode_lb_info_t <parameter>lb</parameter></paramdef>
              <paramdef>int <parameter>opts</parameter></paramdef>
	    </funcprototype>

	    <funcprototype>
              <funcdef>int <function>unicode_lb_next</function></funcdef>
              <paramdef>unicode_lb_info_t <parameter>lb</parameter></paramdef>
              <paramdef>char32_t <parameter>c</parameter></paramdef>
	    </funcprototype>

	    <funcprototype>
              <funcdef>int <function>unicode_lb_next_cnt</function></funcdef>
              <paramdef>unicode_lb_info_t <parameter>lb</parameter></paramdef>
              <paramdef>const char32_t *<parameter>cptr</parameter></paramdef>
              <paramdef>size_t <parameter>cnt</parameter></paramdef>
	    </funcprototype>

	    <funcprototype>
              <funcdef>int <function>unicode_lb_end</function></funcdef>
              <paramdef>unicode_lb_info_t <parameter>lb</parameter></paramdef>
	    </funcprototype>
	  </funcsynopsis>

	  <funcsynopsis>
	    <funcprototype>
              <funcdef>unicode_lbc_info_t <function>unicode_lbc_init</function></funcdef>
              <paramdef>int (*<parameter>cb_func</parameter>)(int, char32_t, void *)</paramdef>
              <paramdef>void *<parameter>cb_arg</parameter></paramdef>
	    </funcprototype>

	    <funcprototype>
              <funcdef>void <function>unicode_lbc_set_opts</function></funcdef>
              <paramdef>unicode_lbc_info_t <parameter>lb</parameter></paramdef>
              <paramdef>int <parameter>opts</parameter></paramdef>
	    </funcprototype>

	    <funcprototype>
              <funcdef>int <function>unicode_lbc_next</function></funcdef>
              <paramdef>unicode_lb_info_t <parameter>lb</parameter></paramdef>
              <paramdef>char32_t <parameter>c</parameter></paramdef>
	    </funcprototype>

	    <funcprototype>
              <funcdef>int <function>unicode_lbc_next_cnt</function></funcdef>
              <paramdef>unicode_lb_info_t <parameter>lb</parameter></paramdef>
              <paramdef>const char32_t *<parameter>cptr</parameter></paramdef>
              <paramdef>size_t <parameter>cnt</parameter></paramdef>
	    </funcprototype>

	    <funcprototype>
              <funcdef>int <function>unicode_lbc_end</function></funcdef>
              <paramdef>unicode_lb_info_t <parameter>lb</parameter></paramdef>
	    </funcprototype>
	  </funcsynopsis>
	</refsynopsisdiv>
	<refsect1>
	  <title>DESCRIPTION</title>
	  <para>
	    These functions implement the unicode line breaking algorithm.
	    Invoke <function>unicode_lb_init</function>() to initialize the
	    line breaking algorithm. The
	    first parameter is a callback function.
	    The second parameter is an opaque pointer.
	    The callback function gets invoked with two parameters. The first
	    parameter is one of three values:
	    <literal>UNICODE_LB_MANDATORY</literal>,
	    <literal>UNICODE_LB_NONE</literal>, or
	    <literal>UNICODE_LB_ALLOWED</literal>, as described below.
	    The second parameter is
	    the opaque pointer that was passed to
	    <function>unicode_lb_init</function>(); the opaque pointer
	    is not subject to any further interpretation by these functions.
	  </para>

	  <para>
	    <function>unicode_lb_init</function>() returns an opaque handle.
	    Repeated invocations of <function>unicode_lb_next</function>(),
	    passing the handle and one unicode character at a time,
	    defines a sequence
	    of unicode characters over which the line breaking algorithm
	    calculation takes place.
	    <function>unicode_lb_next_cnt</function>() is a shortcut
	    for invoking <function>unicode_lb_next</function>()
	    repeatedly over an array
	    <literal>cptr</literal> containing
	    <literal>cnt</literal> unicode characters.
	  </para>

	  <para>
	    <function>unicode_lb_end</function>() denotes the end of the
	    unicode character sequence. After the call to
	    <function>unicode_lb_end</function>() the line breaking
	    <classname>unicode_lb_info_t</classname> handle is no longer valid.
	  </para>

	  <para>
	    Between the call to
	    <function>unicode_lb_init</function>() and
	    <function>unicode_lb_end</function>(), the callback function
	    gets invoked exactly once for each unicode character given to
	    <function>unicode_lb_next</function>() or
	    <function>unicode_lb_next_cnt</function>().
	    Usually each call to
	    <function>unicode_lb_next</function>() results in the callback
	    function getting invoked immediately, but it does not have to be.
	    It's possible that a call to <function>unicode_lb_next</function>()
	    returns without invoking the callback function, and some subsequent
	    call to <function>unicode_lb_next</function>() (or
	    <function>unicode_lb_end</function>()) invokes the callback function
	    more than once, to catch up.
	    The contract is that before <function>unicode_lb_end</function>()
	    returns, the callback function gets invoked the exact number of times
	    as the number of characters in the unicode sequence defined by
	    the intervening calls to <function>unicode_lb_next</function>() and
	    <function>unicode_lb_next_cnt</function>(), unless an error
	    occurs.
	  </para>

	  <para>
	    Each call to the callback function reports the calculated
	    line breaking status of the corresponding character in the unicode
	    character sequence:
	  </para>

	  <variablelist>
	    <varlistentry>
	      <term><literal>UNICODE_LB_MANDATORY</literal></term>
	      <listitem>
		<para>
		  A line break is MANDATORY
		  <emphasis>before</emphasis> the corresponding character.
		</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><literal>UNICODE_LB_NONE</literal></term>
	      <listitem>
		<para>
		  A line break is PROHIBITED
		  <emphasis>before</emphasis> the corresponding character.
		</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><literal>UNICODE_LB_ALLOWED</literal></term>
	      <listitem>
		<para>
		  A line break is OPTIONAL
		  <emphasis>before</emphasis> the corresponding character.
		</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>

	  <para>
	    The callback function should return 0. A non-zero value
	    indicates to the line breaking algorithm that an error has
	    occured.
	    <function>unicode_lb_next</function>() and
	    <function>unicode_lb_next_cnt</function>() return zero either if
	    they never invoked the callback function, or if each call to the
	    callback function returned zero.
	    A non zero return from the callback function results in
	    <function>unicode_lb_next</function>() and
	    <function>unicode_lb_next_cnt</function>() immediately returning
	    the same value.
	  </para>

	  <para>
	    <function>unicode_lb_end</function>() must be invoked to destroy
	    the line breaking handle even if
	    <function>unicode_lb_next</function>() and
	    <function>unicode_lb_next_cnt</function>() returned an error
	    indication. It's also possible that, under normal circumstances,
	    <function>unicode_lb_end</function>() invokes the callback function
	    one or more times. The return value from
	    <function>unicode_lb_end</function>() has the same meaning as
	    from <function>unicode_lb_next</function>() and
	    <function>unicode_lb_next_cnt</function>(); however in all cases
	    after <function>unicode_lb_end</function>() returns the
	    line breaking handle is no longer valid.
	  </para>

	  <refsect2>
	    <title>Alternative callback function</title>

	    <para>
	      <function>unicode_lbc_init</function>(),
	      <function>unicode_lbc_next</function>(),
	      <function>unicode_lbc_next_cnt</function>(),
	      <function>unicode_lbc_end</function>() are alternative functions
	      that implement the same algorithm. The only difference is that
	      the callback function receives an extra parameter, the unicode
	      character value to which the line breaking status applies to,
	      passed through from the input unicode character sequence.
	    </para>
	  </refsect2>

	  <refsect2>
	    <title>Options</title>

	    <para>
	      <function>unicode_lb_set_opts</function>() and
	      <function>unicode_lbc_set_opts</function>() enable non-default
	      options for the line breaking algorithm. These functions must be
	      called immediately after
	      <function>unicode_lb_init</function>() or
	      <function>unicode_lbc_init</function>(), and before any other
	      function.
	      <parameter>opts</parameter> is a bitmask that can contain
	      the following values:
	    </para>

	    <variablelist>
	      <varlistentry>
		<term><literal>UNICODE_LB_OPT_PRBREAK</literal></term>
		<listitem>
		  <para>
		    Enables a modified <literal>LB24</literal> rule.
		    This prevents
		    plus signs, as in <quote>C++</quote> from breaking. This
		    flag adds the following rules to the LB24 rule:
		  </para>

		  <blockquote>
		    <informalexample>
		      <programlisting>
			PR x PR

			AL x PR

		        ID x PR</programlisting>
		    </informalexample>
		  </blockquote>
		</listitem>
	      </varlistentry>
	      <varlistentry>
		<term><literal>UNICODE_LB_OPT_SYBREAK</literal></term>
		<listitem>
		  <para>
		    Tailored breaking rules for the <quote>/</quote> character.
		    This prevents breaking after the <quote>/</quote> character
		    (think URLs); including an exception to the
		    <quote>x SY</quote> rule in <literal>LB13</literal>.
		    This flag adds the following rules to the LB24 rule:
		  </para>
		  <blockquote>
		    <informalexample>
		      <programlisting>
			SY x EX

			SY x AL

			SY x ID

		        SP  SY, which takes precedence over "x SY".</programlisting>
		    </informalexample>
		  </blockquote>
		</listitem>
	      </varlistentry>
	      <varlistentry>
		<term><literal>UNICODE_LB_OPT_DASHWJ</literal></term>
		<listitem>
		  <para>
		    This flag reclassifies <literal>U+2013</literal> and
		    <literal>U+2014</literal> as class <literal>WJ</literal>,
		    prohibiting breaks before and after the m-dash and the
		    n-dash unicode characters.
		  </para>
		</listitem>
	      </varlistentry>
	    </variablelist>
	  </refsect2>
	</refsect1>

	<refsect1>
	  <title>SEE ALSO</title>

	  <para>
	    <link linkend="courier-unicode">
	      <citerefentry>
		<refentrytitle>courier-unicode</refentrytitle>
		<manvolnum>7</manvolnum></citerefentry></link>,
	    <link linkend="unicode__linebreak">
	      <citerefentry><refentrytitle>unicode::linebreak</refentrytitle>
	      <manvolnum>3</manvolnum></citerefentry></link>,
	    <ulink url="https://www.unicode.org/reports/tr14/tr14-&tr14ver;.html">TR-14</ulink>
	  </para>
	</refsect1>
      </refentry>

      <refentry id="unicode_script">
	<refentryinfo><author><firstname>Sam</firstname><surname>Varshavchik</surname><contrib>Author</contrib></author><productname>Courier Unicode Library</productname></refentryinfo>
	<refmeta>
	  <refentrytitle>unicode_script</refentrytitle>
	  <manvolnum>3</manvolnum>
	</refmeta>

	<refnamediv>
	  <refname>unicode_script</refname>
	  <refpurpose>unicode script property</refpurpose>
	</refnamediv>

	<refsynopsisdiv>
	  <funcsynopsis>
	    <funcsynopsisinfo>#include &lt;courier-unicode.h&gt;</funcsynopsisinfo>
	    <funcprototype>
              <funcdef>unicode_script_t <function>unicode_script</function></funcdef>
              <paramdef>char32_t <parameter>ch</parameter></paramdef>
	    </funcprototype>
	  </funcsynopsis>
	</refsynopsisdiv>
	<refsect1>
	  <title>DESCRIPTION</title>
	  <para>
	    <function>unicode_script</function>() looks up the
	    <quote>script</quote> property of the specified unicode character,
	    and returns it. The <classname>unicode_script_t</classname>
	    enumeration encodes possible unicode script values.
	    <literal>unicode_script_unknown</literal> gets returned for a
	    unicode character  with an unknown script property.
	  </para>
	</refsect1>

	<refsect1>
	  <title>SEE ALSO</title>

	  <para>
	    <ulink url="https://www.unicode.org/reports/tr24/tr24-&tr24ver;.html">TR-24</ulink>,
	    <link linkend="courier-unicode">
	      <citerefentry>
		<refentrytitle>courier-unicode</refentrytitle>
		<manvolnum>7</manvolnum></citerefentry></link>.
	  </para>
	</refsect1>
      </refentry>

      <refentry id="unicode_word_break">
	<refentryinfo><author><firstname>Sam</firstname><surname>Varshavchik</surname><contrib>Author</contrib></author><productname>Courier Unicode Library</productname></refentryinfo>
	<refmeta>
	  <refentrytitle>unicode_word_break</refentrytitle>
	  <manvolnum>3</manvolnum>
	</refmeta>

	<refnamediv>
	  <refname>unicode_wb_init</refname>
	  <refname>unicode_wb_next</refname>
	  <refname>unicode_wb_next_cnt</refname>
	  <refname>unicode_wb_end</refname>

	  <refname>unicode_wbscan_init</refname>
	  <refname>unicode_wbscan_next</refname>
	  <refname>unicode_wbscan_end</refname>

	  <refpurpose>calculate word breaks</refpurpose>
	</refnamediv>

	<refsynopsisdiv>
	  <funcsynopsis>
	    <funcsynopsisinfo>#include &lt;courier-unicode.h&gt;</funcsynopsisinfo>
	    <funcprototype>
              <funcdef>unicode_wb_info_t <function>unicode_wb_init</function></funcdef>
              <paramdef>int (*<parameter>cb_func</parameter>)(int, void *)</paramdef>
              <paramdef>void *<parameter>cb_arg</parameter></paramdef>
	    </funcprototype>

	    <funcprototype>
              <funcdef>int <function>unicode_wb_next</function></funcdef>
              <paramdef>unicode_wb_info_t <parameter>wb</parameter></paramdef>
              <paramdef>char32_t <parameter>c</parameter></paramdef>
	    </funcprototype>

	    <funcprototype>
              <funcdef>int <function>unicode_wb_next_cnt</function></funcdef>
              <paramdef>unicode_wb_info_t <parameter>wb</parameter></paramdef>
              <paramdef>const char32_t *<parameter>cptr</parameter></paramdef>
              <paramdef>size_t <parameter>cnt</parameter></paramdef>
	    </funcprototype>

	    <funcprototype>
              <funcdef>int <function>unicode_wb_end</function></funcdef>
              <paramdef>unicode_wb_info_t <parameter>wb</parameter></paramdef>
	    </funcprototype>

	    <funcprototype>
              <funcdef>unicode_wbscan_info_t <function>unicode_wbscan_init</function></funcdef>
	      <void />
	    </funcprototype>

	    <funcprototype>
              <funcdef>int <function>unicode_wbscan_next</function></funcdef>
              <paramdef>unicode_wbscan_info_t <parameter>wbs</parameter></paramdef>
              <paramdef>char32_t <parameter>c</parameter></paramdef>
	    </funcprototype>

	    <funcprototype>
              <funcdef>size_t <function>unicode_wbscan_end</function></funcdef>
              <paramdef>unicode_wbscan_info_t <parameter>wbs</parameter></paramdef>
	    </funcprototype>

	  </funcsynopsis>
	</refsynopsisdiv>
	<refsect1>
	  <title>DESCRIPTION</title>
	  <para>
	    These functions implement the unicode word breaking algorithm.
	    Invoke <function>unicode_wb_init</function>() to initialize the
	    word breaking algorithm. The
	    first parameter is a callback function.
	    The second parameter is an opaque pointer.
	    The callback function gets invoked with two parameters.
	    The second parameter is
	    the opaque pointer that was given to
	    <function>unicode_wb_init</function>(); and the opaque pointer
	    is not subject to any further interpretation by these functions.
	  </para>

	  <para>
	    <function>unicode_wb_init</function>() returns an opaque handle.
	    Repeated invocations of <function>unicode_wb_next</function>(),
	    passing the handle, and one unicode character defines a sequence
	    of unicode characters over which the word breaking algorithm
	    calculation takes place.
	    <function>unicode_wb_next_cnt</function>() is a shortcut
	    for invoking <function>unicode_wb_next</function>()
	    repeatedly over an array
	    <literal>cptr</literal> containing
	    <literal>cnt</literal> unicode characters.
	  </para>

	  <para>
	    <function>unicode_wb_end</function>() denotes the end of the
	    unicode character sequence. After the call to
	    <function>unicode_wb_end</function>() the word breaking
	    <classname>unicode_wb_info_t</classname> handle is no longer valid.
	  </para>

	  <para>
	    Between the call to
	    <function>unicode_wb_init</function>() and
	    <function>unicode_wb_end</function>(), the callback function
	    gets invoked exactly once for each unicode character given to
	    <function>unicode_wb_next</function>() or
	    <function>unicode_wb_next_cnt</function>().
	    Usually each call to
	    <function>unicode_wb_next</function>() results in the callback
	    function getting invoked immediately, but it does not have to be.
	    It's possible that a call to <function>unicode_wb_next</function>()
	    returns without invoking the callback function, and some subsequent
	    call to <function>unicode_wb_next</function>() (or
	    <function>unicode_wb_end</function>()) invokes the callback function
	    more than once, to catch things up.
	    The contract is that before <function>unicode_wb_end</function>()
	    returns, the callback function gets invoked the exact number of times
	    as the number of characters in the unicode sequence defined by
	    the intervening calls to <function>unicode_wb_next</function>() and
	    <function>unicode_wb_next_cnt</function>(), unless an error
	    occurs.
	  </para>

	  <para>
	    Each call to the callback function reports the calculated
	    wordbreaking status of the corresponding character in the unicode
	    character sequence. If the parameter to the callback function
	    is non zero, a word break is permitted <emphasis>before</emphasis>
	    the corresponding character. A zero value indicates that a word
	    break is prohibited <emphasis>before</emphasis> the corresponding
	    character.
	  </para>

	  <para>
	    The callback function should return 0. A non-zero value
	    indicates to the word breaking algorithm that an error has
	    occured.
	    <function>unicode_wb_next</function>() and
	    <function>unicode_wb_next_cnt</function>() return zero either if
	    they never invoked the callback function, or if each call to the
	    callback function returned zero.
	    A non zero return from the callback function results in
	    <function>unicode_wb_next</function>() and
	    <function>unicode_wb_next_cnt</function>() immediately returning
	    the same value.
	  </para>

	  <para>
	    <function>unicode_wb_end</function>() must be invoked to destroy
	    the word breaking handle even if
	    <function>unicode_wb_next</function>() and
	    <function>unicode_wb_next_cnt</function>() returned an error
	    indication. It's also possible that, under normal circumstances,
	    <function>unicode_wb_end</function>() invokes the callback function
	    one or more times. The return value from
	    <function>unicode_wb_end</function>() has the same meaning as
	    from <function>unicode_wb_next</function>() and
	    <function>unicode_wb_next_cnt</function>(); however in all cases
	    after <function>unicode_wb_end</function>() returns the
	    line breaking handle is no longer valid.
	  </para>

	  <refsect2>
	    <title>Word scan</title>

	    <para>
	      <function>unicode_wbscan_init</function>(),
              <function>unicode_wbscan_next</function>() and
              <function>unicode_wbscan_end</function>
	      scan for the next word boundary in a unicode character sequence.

	      <function>unicode_wbscan_init</function>() obtains a handle,
	      then
              <function>unicode_wbscan_next</function>() gets repeatedly invoked
	      to define the unicode character sequence.
	      <function>unicode_wbscan_end</function>() deallocates the handle
	      and returns the number of leading characters in the unicode character
	      sequence up to the first word break.
	    </para>

	    <para>
	      A non-0 return value from
              <function>unicode_wbscan_next</function>() indicates that the
	      word boundary is already known, and any further calls to
              <function>unicode_wbscan_next</function>() will be ignored.
	      <function>unicode_wbscan_end</function>() must still be called,
	      to obtain the unicode character count.
	    </para>
	  </refsect2>
	</refsect1>

	<refsect1>
	  <title>SEE ALSO</title>
	  <para>
	    <ulink url="https://www.unicode.org/reports/tr29/tr29-&tr29ver;.html">TR-29</ulink>,
	    <link linkend="courier-unicode">
	      <citerefentry>
		<refentrytitle>courier-unicode</refentrytitle>
		<manvolnum>7</manvolnum></citerefentry></link>,
	    <link linkend="unicode_word_break">
	      <citerefentry><refentrytitle>unicode::wordbreak</refentrytitle>
	      <manvolnum>3</manvolnum></citerefentry></link>,
	      <link linkend="unicode_uc">
		<citerefentry><refentrytitle>unicode_convert_tocase</refentrytitle>
		<manvolnum>3</manvolnum></citerefentry></link>,
		<link linkend="unicode_line_break">
		  <citerefentry><refentrytitle>unicode_line_break</refentrytitle>
		  <manvolnum>3</manvolnum></citerefentry></link>,
		  <link linkend="unicode_grapheme_break">
		    <citerefentry><refentrytitle>unicode_grapheme_break</refentrytitle>
		    <manvolnum>3</manvolnum></citerefentry></link>.
	  </para>
	</refsect1>
      </refentry>

      <refentry id="unicode_uc">
	<refentryinfo><author><firstname>Sam</firstname><surname>Varshavchik</surname><contrib>Author</contrib></author><productname>Courier Unicode Library</productname></refentryinfo>
	<refmeta>
	  <refentrytitle>unicode_uc</refentrytitle>
	  <manvolnum>3</manvolnum>
	</refmeta>

	<refnamediv>
	  <refname>unicode_uc</refname>
	  <refname>unicode_lc</refname>
	  <refname>unicode_tc</refname>
	  <refname>unicode_convert_tocase</refname>
	  <refpurpose>unicode uppercase, lowercase, and titlecase character lookup</refpurpose>
	</refnamediv>

	<refsynopsisdiv>
	  <funcsynopsis>
	    <funcsynopsisinfo>#include &lt;courier-unicode.h&gt;</funcsynopsisinfo>
	    <funcprototype>
              <funcdef>char32_t <function>unicode_uc</function></funcdef>
              <paramdef>char32_t <parameter>c</parameter></paramdef>
	    </funcprototype>
	  </funcsynopsis>
	  <funcsynopsis>
	    <funcprototype>
              <funcdef>char32_t <function>unicode_lc</function></funcdef>
              <paramdef>char32_t <parameter>c</parameter></paramdef>
	    </funcprototype>
	  </funcsynopsis>
	  <funcsynopsis>
	    <funcprototype>
              <funcdef>char32_t <function>unicode_tc</function></funcdef>
              <paramdef>char32_t <parameter>c</parameter></paramdef>
	    </funcprototype>
	  </funcsynopsis>
	  <funcsynopsis>
	    <funcprototype>
              <funcdef>char *<function>unicode_convert_tocase</function></funcdef>
              <paramdef>const char *<parameter>str</parameter></paramdef>
              <paramdef>const char *<parameter>charset</parameter></paramdef>
              <paramdef>char32_t (*<parameter>first_char_func</parameter>)(uncode_char)</paramdef>
              <paramdef>char32_t (*<parameter>char_func</parameter>)(uncode_char)</paramdef>
	    </funcprototype>
	  </funcsynopsis>
	</refsynopsisdiv>
	<refsect1>
	  <title>DESCRIPTION</title>
	  <para>
	    <function>unicode_uc</function>(),
	    <function>unicode_lc</function>(),
	    <function>unicode_tc</function>()
	    return the uppercase, lowercase, or the titlecase
	    equivalent of the unicode character <parameter>c</parameter>.
	    If this character does not have an uppercase, lowercase, or a titlecase
	    equivalent, these functions return <parameter>c</parameter>, the
	    same character.
	  </para>

	  <para>
	    <function>unicode_convert_tocase</function>()
	    takes the string <parameter>str</parameter> in the
	    character set <parameter>charset</parameter>.
	    <parameter>first_char_func</parameter> and
	    <parameter>char_func</parameter>, each, should be
	    <function>unicode_uc</function>,
	    <function>unicode_lc</function>, or
	    <function>unicode_tc</function>.
	    <function>unicode_convert_tocase</function>() returns a malloc()ed
	    buffer. The first unicode character in
	    <parameter>str</parameter> gets processed by
	    <parameter>first_char_func</parameter>, and all other characters by
	    <parameter>char_func</parameter>.
	  </para>
	</refsect1>

	<refsect1>
	  <title>SEE ALSO</title>
	  <para>
	    <link linkend="courier-unicode">
	      <citerefentry>
		<refentrytitle>courier-unicode</refentrytitle>
		<manvolnum>7</manvolnum></citerefentry></link>,
	    <link linkend="unicode_convert">
	      <citerefentry>
		<refentrytitle>unicode_convert</refentrytitle>
		<manvolnum>3</manvolnum></citerefentry></link>,
	      <link linkend="unicode_default_chset">
		<citerefentry><refentrytitle>unicode_default_chset</refentrytitle>
		<manvolnum>3</manvolnum></citerefentry></link>,
		<link linkend="unicode_html40ent_lookup">
		  <citerefentry><refentrytitle>unicode_html40ent_lookup</refentrytitle>
		  <manvolnum>3</manvolnum></citerefentry></link>,
		  <link linkend="unicode_category_lookup">
		    <citerefentry><refentrytitle>unicode_category_lookup</refentrytitle>
		    <manvolnum>3</manvolnum></citerefentry></link>,
		    <link linkend="unicode_grapheme_break">
		      <citerefentry><refentrytitle>unicode_grapheme_break</refentrytitle>
		      <manvolnum>3</manvolnum></citerefentry></link>,
		      <link linkend="unicode_word_break">
			<citerefentry><refentrytitle>unicode_word_break</refentrytitle>
			<manvolnum>3</manvolnum></citerefentry></link>,
			<link linkend="unicode_line_break">
			  <citerefentry><refentrytitle>unicode_line_break</refentrytitle>
			  <manvolnum>3</manvolnum></citerefentry></link>.

	  </para>
	</refsect1>
      </refentry>
    </section>

    <section id="manpagescpp">
      <title>C++ manual pages</title>

      <refentry id="unicode__bidi">
	<refentryinfo><author><firstname>Sam</firstname><surname>Varshavchik</surname><contrib>Author</contrib></author><productname>Courier Unicode Library</productname></refentryinfo>

	<refmeta>
	  <refentrytitle>unicode::bidi::calc</refentrytitle>
	  <manvolnum>3</manvolnum>
	</refmeta>

	<refnamediv>
	  <refname>unicode::bidi_calc</refname>
	  <refname>unicode::bidi_reorder</refname>
	  <refpurpose>unicode bidirectional algorithm</refpurpose>
	</refnamediv>

	<refsynopsisdiv>
	  <funcsynopsis>
	    <funcsynopsisinfo>#include &lt;courier-unicode.h&gt;</funcsynopsisinfo>
	    <funcprototype>
              <funcdef>std::vector&lt;unicode_bidi_level_t&gt; <function>unicode::bidi_calc</function></funcdef>
	      <paramdef>const std::u32string &amp;<parameter>string</parameter></paramdef>
	    </funcprototype>
	  </funcsynopsis>

	  <funcsynopsis>
	    <funcprototype>
              <funcdef>std::vector&lt;unicode_bidi_level_t&gt; <function>unicode::bidi_calc</function></funcdef>
	      <paramdef>const std::u32string &amp;<parameter>string</parameter></paramdef>
	      <paramdef>unicode_bidi_level_t <parameter>embedding_level</parameter></paramdef>
	    </funcprototype>
	  </funcsynopsis>

	  <funcsynopsis>
	    <funcprototype>
              <funcdef>int <function>unicode::bidi_reorder</function></funcdef>
	      <paramdef>std::u32string &amp;<parameter>string</parameter></paramdef>
	      <paramdef>std::vector&lt;unicode_bidi_level_t&gt; &amp;<parameter>embedding_level</parameter></paramdef>
	      <paramdef>const std::function&lt;void (size_t, size_t)&gt; &amp;<parameter>reorder_callback</parameter></paramdef>
	    </funcprototype>
	  </funcsynopsis>

	  <funcsynopsis>
	    <funcprototype>
              <funcdef>int <function>unicode::bidi_reorder</function></funcdef>
	      <paramdef>std::vector&lt;unicode_bidi_level_t&gt; &amp;<parameter>embedding_level</parameter></paramdef>
	      <paramdef>const std::function&lt;void (size_t, size_t)&gt; &amp;<parameter>reorder_callback</parameter></paramdef>
	    </funcprototype>
	  </funcsynopsis>
	</refsynopsisdiv>

	<refsect1>
	  <title>DESCRIPTION</title>

	  <para>
	    These functions implement the C++ interface for the
	    <ulink url="https://www.unicode.org/reports/tr9/tr9-&tr9ver;.html"> Unicode Bi-directional algorithm</ulink>.
	    See the description of the underlying
	    <link linkend="unicode_bidi">
	      <citerefentry><refentrytitle>unicode_bidi</refentrytitle>
	      <manvolnum>3</manvolnum></citerefentry></link> C library
	      API for more information.
	  </para>

	  <para>
            <function>unicode::bidi_calc</function> computes and return a vector
	    of bidirection embedding level values for the given Unicode string.
	    An overload takes an additional parameter that override the
	    paragraph embedding level, a <literal>UNICODE_BIDI_LR</literal> or
            an <literal>UNICODE_BIDI_RL</literal> value.
          </para>
	  <para>
            <function>unicode::bidi_reorder</function> reverses the characters
	    in the Unicode script, according to their embedding levels (and
	    reverses the corresponding embedding level values too).
	    As is with the C API, an optional parameter is a callable object
	    that gets invoked to report each range of characters that gets
	    reversed (specified as the starting position and a number of
	    characters).
          </para>
	  <para>
	    An overloaded <function>unicode::bidi_reorder</function> without
	    the string parameter goes through the motions, according to the
	    embedded level vector parameter, but without actually reversing
	    the values in the vector, but still invoking the callable object
	    normally.
          </para>
	  <para>
	    This is comparable to the C API. Also comparable with the C API:
	    the convention that even embedding levels specify left to right
	    text and odd embedding values specify right to left text.
	    An embedding value of <literal>UNICODE_BIDI_SKIP</literal>
	    indicates an embedding or an override marker that has no
	    specified embeded value. These markers may be removed from the
	    Unicode string (together with the
	    <literal>UNICODE_BIDI_SKIP</literal>
	    values from the embedding values vector) either before or after
	    they get reordered.
	  </para>
	</refsect1>
	<refsect1>
	  <title>SEE ALSO</title>
	  <para>
	    <link linkend="courier-unicode">
	      <citerefentry>
		<refentrytitle>courier-unicode</refentrytitle>
		<manvolnum>7</manvolnum></citerefentry></link>,
	    <link linkend="unicode_bidi">
	      <citerefentry><refentrytitle>unicode_bidi</refentrytitle>
	      <manvolnum>3</manvolnum></citerefentry></link>.
          </para>
        </refsect1>
      </refentry>


      <refentry id="unicode__iconvert__convert">
	<refentryinfo><author><firstname>Sam</firstname><surname>Varshavchik</surname><contrib>Author</contrib></author><productname>Courier Unicode Library</productname></refentryinfo>

	<refmeta>
	  <refentrytitle>unicode::iconvert::convert</refentrytitle>
	  <manvolnum>3</manvolnum>
	</refmeta>

	<refnamediv>
	  <refname>unicode::iconvert::convert</refname>
	  <refname>unicode::ucs_4</refname>
	  <refname>unicode::ucs_2</refname>
	  <refname>unicode::utf_8</refname>
	  <refname>unicode::iso_8859_1</refname>

	  <refpurpose>unicode character set conversion</refpurpose>
	</refnamediv>

	<refsynopsisdiv>
	  <funcsynopsis>
	    <funcsynopsisinfo>#include &lt;courier-unicode.h&gt;

extern const char unicode::ucs_4[];
extern const char unicode::ucs_2[];
extern const char unicode::utf_8[];
extern const char unicode::iso_8859_1[];</funcsynopsisinfo>

	    <funcprototype>
              <funcdef>std::string <function>unicode::iconvert::convert</function></funcdef>
              <paramdef>const std::string &amp;<parameter>text</parameter></paramdef>
              <paramdef>const std::string &amp;<parameter>srccharset</parameter></paramdef>
              <paramdef>const std::string &amp;<parameter>dstcharset</parameter></paramdef>
	    </funcprototype>

	    <funcprototype>
              <funcdef>std::string <function>unicode::iconvert::convert</function></funcdef>
              <paramdef>const std::string &amp;<parameter>text</parameter></paramdef>
              <paramdef>const std::string &amp;<parameter>srccharset</parameter></paramdef>
              <paramdef>const std::string &amp;<parameter>dstcharset</parameter></paramdef>
              <paramdef>bool &amp;<parameter>errflag</parameter></paramdef>
	    </funcprototype>

	    <funcprototype>
              <funcdef>std::string <function>unicode::iconvert::convert</function></funcdef>
              <paramdef>const std::vector&lt;char32_t&gt; &amp;<parameter>text</parameter></paramdef>
              <paramdef>const std::string &amp;<parameter>dstcharset</parameter></paramdef>
	    </funcprototype>

	    <funcprototype>
              <funcdef>std::string <function>unicode::iconvert::convert</function></funcdef>
              <paramdef>const std::vector&lt;char32_t&gt; &amp;<parameter>text</parameter></paramdef>
              <paramdef>const std::string &amp;<parameter>dstcharset</parameter></paramdef>
              <paramdef>bool &amp;<parameter>errflag</parameter></paramdef>
	    </funcprototype>

	    <funcprototype>
              <funcdef>bool <function>unicode::iconvert::convert</function></funcdef>
              <paramdef>const std::string &amp;<parameter>text</parameter></paramdef>
              <paramdef>const std::string &amp;<parameter>charset</parameter></paramdef>
              <paramdef>std::vector&lt;char32_t&gt; &amp;<parameter>text</parameter></paramdef>
	    </funcprototype>
	  </funcsynopsis>
	</refsynopsisdiv>

	<refsect1>
	  <title>DESCRIPTION</title>

	  <para>
	    The overloaded
	    <function>unicode::convert::convert</function>() functions
	    convert:
	  </para>

	  <itemizedlist>
	    <listitem>
	      <para>
		A text string between two different character sets, returning
		the new string.
	      </para>
	    </listitem>

	    <listitem>
	      <para>
		A vector of unicode characters (not null-terminated) to
		a character string in a supported character set.
	      </para>
	    </listitem>

	    <listitem>
	      <para>
		Initialize a vector of unicode characters, passed by
		reference, by converting a text string in a given character
		set to unicode.
	      </para>
	    </listitem>
	  </itemizedlist>

	  <para>
	    These functions use
	    <citerefentry><refentrytitle>iconv</refentrytitle>
	    <manvolnum>3</manvolnum></citerefentry>, and can use any
	    character set that's supported by
	    <citerefentry><refentrytitle>iconv</refentrytitle>
	    <manvolnum>3</manvolnum></citerefentry>.

	    Use
	    <varname>unicode::ucs_2</varname> and
	    <varname>unicode::ucs_4</varname> to specify the 16 and the 32 bit
	    unicode octet in native byte order.
	    Use
	    <varname>unicode::utf_8</varname> and
	    <varname>unicode::iso_8859_1</varname> to specify these two
	    standard character sets.

	    The overloaded versions that pass a reference to a
	    <classname>bool</classname> set the flag to <literal>true</literal>
	    if some characters could not be converted.
	    The overloaded version that initializes a unicode vector returns
	    the <classname>bool</classname> flag, instead.
	  </para>
	</refsect1>

	<refsect1>
	  <title>SEE ALSO</title>
	  <para>
	    <link linkend="courier-unicode">
	      <citerefentry>
		<refentrytitle>courier-unicode</refentrytitle>
		<manvolnum>7</manvolnum></citerefentry></link>,
	    <link linkend="unicode__iconvert__convert_tocase">
	      <citerefentry><refentrytitle>unicode::convert::convert_tocase</refentrytitle>
	      <manvolnum>3</manvolnum></citerefentry></link>,
	    <link linkend="unicode_convert">
	      <citerefentry><refentrytitle>unicode_convert</refentrytitle>
	      <manvolnum>3</manvolnum></citerefentry></link>,
	      <ulink url="https://manpages.courier-mta.org/htmlman3/iconv.3.html">
	      <citerefentry><refentrytitle>iconv</refentrytitle>
	      <manvolnum>3</manvolnum></citerefentry></ulink>.

	  </para>
	</refsect1>
      </refentry>

      <refentry id="unicode__iconvert__convert_tocase">
	<refentryinfo><author><firstname>Sam</firstname><surname>Varshavchik</surname><contrib>Author</contrib></author><productname>Courier Unicode Library</productname></refentryinfo>

	<refmeta>
	  <refentrytitle>unicode::iconvert::convert_tocase</refentrytitle>
	  <manvolnum>3</manvolnum>
	</refmeta>

	<refnamediv>
	  <refname>unicode::iconvert::convert_tocase</refname>

	  <refpurpose>unicode uppercase, lowercase, and titlecase conversion</refpurpose>
	</refnamediv>

	<refsynopsisdiv>
	  <funcsynopsis>
	    <funcsynopsisinfo>#include &lt;courier-unicode.h&gt;</funcsynopsisinfo>

	    <funcprototype>
              <funcdef>std::string <function>unicode::iconvert::convert_tocase</function></funcdef>
              <paramdef>const std::string &amp;<parameter>text</parameter></paramdef>
              <paramdef>const std::string &amp;<parameter>charset</parameter></paramdef>
              <paramdef>char32_t (*<parameter>first_char_func</parameter>)(char32_t)</paramdef>
              <paramdef>char32_t (*<parameter>char_func</parameter>)(char32_t)</paramdef>
	    </funcprototype>

	    <funcprototype>
              <funcdef>std::string <function>unicode::iconvert::convert_tocase</function></funcdef>
              <paramdef>const std::string &amp;<parameter>text</parameter></paramdef>
              <paramdef>const std::string &amp;<parameter>charset</parameter></paramdef>
              <paramdef>bool &amp;<parameter>err</parameter></paramdef>
              <paramdef>char32_t (*<parameter>first_char_func</parameter>)(char32_t)</paramdef>
              <paramdef>char32_t (*<parameter>char_func</parameter>)(char32_t)</paramdef>
	    </funcprototype>
	  </funcsynopsis>
	</refsynopsisdiv>

	<refsect1>
	  <title>DESCRIPTION</title>

	  <para>
	    The overloaded
	    <function>unicode::convert::convert_tocase</function>() function
	    converts the <parameter>text</parameter> parameter, in the
	    <parameter>charset</parameter> characters to lowercase, uppercase,
	    and titlecase. <parameter>text</parameter> gets converted,
	    internally, into unicode.
            <parameter>first_char_func</parameter> and
            <parameter>char_func</parameter> are either:
	    <function>unicode_lc</function>,
	    <function>unicode_uc</function>, or
	    <function>unicode_tc</function>. If the converted text string is
	    not empty, <parameter>first_char_func</parameter> converts the
	    first unicode character in the text string, and
            <parameter>char_func</parameter> converts any remaining characters.
	    <function>unicode_lc</function> converts its character to lowercase,
	    <function>unicode_uc</function> to uppercase, and
	    <function>unicode_tc</function> to titlecase. Finally, the
	    unicode string gets converted back to
	    <parameter>charset</parameter>, which gets returned.
	  </para>

	  <para>
	    The optional <parameter>err</parameter> parameter gets set to true if
	    an error was encounted converting the text string to or from
	    unicode.
	  </para>
	</refsect1>

	<refsect1>
	  <title>SEE ALSO</title>
	  <para>
	    <link linkend="courier-unicode">
	      <citerefentry>
		<refentrytitle>courier-unicode</refentrytitle>
		<manvolnum>7</manvolnum></citerefentry></link>,
	    <link linkend="unicode__iconvert__convert">
	      <citerefentry><refentrytitle>unicode::convert::convert</refentrytitle>
	      <manvolnum>3</manvolnum></citerefentry></link>,
	    <link linkend="unicode_convert">
	      <citerefentry><refentrytitle>unicode_convert</refentrytitle>
	      <manvolnum>3</manvolnum></citerefentry></link>,
	      <ulink url="https://manpages.courier-mta.org/htmlman3/iconv.3.html">
	      <citerefentry><refentrytitle>iconv</refentrytitle>
	      <manvolnum>3</manvolnum></citerefentry></ulink>.

	  </para>
	</refsect1>
      </refentry>

      <refentry id="unicode__iconvert__fromu">
	<refentryinfo><author><firstname>Sam</firstname><surname>Varshavchik</surname><contrib>Author</contrib></author><productname>Courier Unicode Library</productname></refentryinfo>

	<refmeta>
	  <refentrytitle>unicode::iconvert::fromu</refentrytitle>
	  <manvolnum>3</manvolnum>
	</refmeta>

	<refnamediv>
	  <refname>unicode::iconvert::fromu</refname>

	  <refpurpose>template for converting text sequence from unicode</refpurpose>
	</refnamediv>

	<refsynopsisdiv>
	  <funcsynopsis>
	    <funcsynopsisinfo>#include &lt;courier-unicode.h&gt;</funcsynopsisinfo>

	    <funcprototype>
              <funcdef>output_iter_t <function>unicode::iconvert::fromu::convert</function></funcdef>
              <paramdef>input_iter_t <parameter>beg_iter</parameter></paramdef>
              <paramdef>input_iter_t <parameter>end_iter</parameter></paramdef>
              <paramdef>const std::string &amp;<parameter>charset</parameter></paramdef>
              <paramdef>output_iter_t <parameter>output_iter</parameter></paramdef>
              <paramdef>bool &amp;<parameter>errflag</parameter></paramdef>
	    </funcprototype>

	    <funcprototype>
              <funcdef>void <function>unicode::iconvert::fromu::convert</function></funcdef>
              <paramdef>input_iter_t <parameter>beg_iter</parameter></paramdef>
              <paramdef>input_iter_t <parameter>end_iter</parameter></paramdef>
              <paramdef>const std::string &amp;<parameter>charset</parameter></paramdef>
              <paramdef>std::string &amp;<parameter>out_buf</parameter></paramdef>
              <paramdef>bool &amp;<parameter>errflag</parameter></paramdef>
	    </funcprototype>

	    <funcprototype>
              <funcdef>std::pair&lt;std::string, bool&gt; <function>unicode::iconvert::fromu::convert</function></funcdef>
              <paramdef>const std::u32string &amp;<parameter>text</parameter></paramdef>
              <paramdef>const std::string &amp;<parameter>charset</parameter></paramdef>
	    </funcprototype>
	  </funcsynopsis>
	</refsynopsisdiv>

	<refsect1>
	  <title>DESCRIPTION</title>

	  <para>
	    These template functions convert unicode characters to
	    text in the given character set.
	    <parameter>beg_iter</parameter> and
	    <parameter>end_iter</parameter> define an input sequence of
	    <classname>char32_t</classname>s.
	    They get converted to unicode characters.
	    <parameter>output_iter</parameter> is an output iterator that
	    <function>convert</function>()
	    iterates over <classname>char</classname>s in the specified
	    character set.
	    <function>convert</function>() returns the value of the output
	    iterator after iterating over the converted character sequence.
	    <parameter>err_flag</parameter> gets set to <literal>true</literal>
	    if unicode text could not be converted to the requested character
	    set, or <literal>false</literal> for a successful conversion.
	  </para>

	  <para>
	    An overloaded <function>convert</function>() puts the text string
	    into a <classname>std::string</classname>, instead of using
	    an output iterator.
	    Finally, a single
	    <classname>std::u32string</classname>
	    specifies the character string, instead of a beginning and an
	    ending iterator.
	  </para>
	</refsect1>

	<refsect1>
	  <title>SEE ALSO</title>
	  <para>
	    <link linkend="courier-unicode">
	      <citerefentry>
		<refentrytitle>courier-unicode</refentrytitle>
		<manvolnum>7</manvolnum></citerefentry></link>,
	    <link linkend="unicode__iconvert__convert">
	      <citerefentry><refentrytitle>unicode::convert::convert</refentrytitle>
	      <manvolnum>3</manvolnum></citerefentry></link>,
	    <link linkend="unicode_convert">
	      <citerefentry><refentrytitle>unicode_convert</refentrytitle>
	      <manvolnum>3</manvolnum></citerefentry></link>,
	      <ulink url="https://manpages.courier-mta.org/htmlman3/iconv.3.html">
	      <citerefentry><refentrytitle>iconv</refentrytitle>
	      <manvolnum>3</manvolnum></citerefentry></ulink>.

	  </para>
	</refsect1>
      </refentry>

      <refentry id="unicode__iconvert__tou">
	<refentryinfo><author><firstname>Sam</firstname><surname>Varshavchik</surname><contrib>Author</contrib></author><productname>Courier Unicode Library</productname></refentryinfo>

	<refmeta>
	  <refentrytitle>unicode::iconvert::tou</refentrytitle>
	  <manvolnum>3</manvolnum>
	</refmeta>

	<refnamediv>
	  <refname>unicode::iconvert::tou</refname>

	  <refpurpose>template for converting text sequence to unicode</refpurpose>
	</refnamediv>

	<refsynopsisdiv>
	  <funcsynopsis>
	    <funcsynopsisinfo>#include &lt;courier-unicode.h&gt;</funcsynopsisinfo>

	    <funcprototype>
              <funcdef>output_iter_t <function>convert</function></funcdef>
              <paramdef>input_iter_t <parameter>beg_iter</parameter></paramdef>
              <paramdef>input_iter_t <parameter>end_iter</parameter></paramdef>
              <paramdef>const std::string &amp;<parameter>charset</parameter></paramdef>
	      <paramdef>bool &amp;<parameter>errflag</parameter></paramdef>
              <paramdef>output_iter_t <parameter>output_iter</parameter></paramdef>
	    </funcprototype>

	    <funcprototype>
              <funcdef>bool <function>convert</function></funcdef>
              <paramdef>input_iter_t <parameter>beg_iter</parameter></paramdef>
              <paramdef>input_iter_t <parameter>end_iter</parameter></paramdef>
              <paramdef>const std::string &amp;<parameter>charset</parameter></paramdef>
              <paramdef>std::u32string &amp;<parameter>out_buf</parameter></paramdef>
	    </funcprototype>

	    <funcprototype>
              <funcdef>std::pair&lt;std::u32string, bool&gt; <function>convert</function></funcdef>
              <paramdef>const std::string &amp;<parameter>text</parameter></paramdef>
              <paramdef>const std::string &amp;<parameter>charset</parameter></paramdef>
	    </funcprototype>
	  </funcsynopsis>
	</refsynopsisdiv>

	<refsect1>
	  <title>DESCRIPTION</title>

	  <para>
	    These template functions convert text in a given character set
	    to unicode characters.
	    <parameter>beg_iter</parameter> and
	    <parameter>end_iter</parameter> define an input sequence of
	    <classname>char</classname>s in the <parameter>charset</parameter>
	    character set. They get converted to unicode characters.
	    <parameter>output_iter</parameter> is an output iterator that
	    <function>convert</function>()
	    iterates over <classname>char32_t</classname>s.
	    <function>convert</function>() returns the value of the output
	    iterator after iterating over the converted character sequence.
	    <parameter>errflag</parameter>, passed by reference, gets set to
	    <literal>true</literal> if some character could not be converted
	    to unicode, from the specified character set, and
	    <literal>false</literal> if the conversion completed without
	    errors.
	  </para>

	  <para>
	    An overloaded <function>convert</function>() puts the unicode
	    character sequence into a vector of
	    <classname>char32_t</classname>s, instead of an output
	    sequence, and returned the error flag.
	    Finally, a single <classname>std::string</classname>
	    specifies the character string, instead of a beginning and an
	    ending iterator, and returns a
	    <classname>std::pair</classname> with the converted unicode
	    text in a vector, and the error flag.
	  </para>
	</refsect1>

	<refsect1>
	  <title>SEE ALSO</title>
	  <para>
	    <link linkend="courier-unicode">
	      <citerefentry>
		<refentrytitle>courier-unicode</refentrytitle>
		<manvolnum>7</manvolnum></citerefentry></link>,
	    <link linkend="unicode__iconvert__convert">
	      <citerefentry><refentrytitle>unicode::convert::convert</refentrytitle>
	      <manvolnum>3</manvolnum></citerefentry></link>,
	    <link linkend="unicode_convert">
	      <citerefentry><refentrytitle>unicode_convert</refentrytitle>
	      <manvolnum>3</manvolnum></citerefentry></link>,
	      <ulink url="https://manpages.courier-mta.org/htmlman3/iconv.3.html">
	      <citerefentry><refentrytitle>iconv</refentrytitle>
	      <manvolnum>3</manvolnum></citerefentry></ulink>.

	  </para>
	</refsect1>
      </refentry>

      <refentry id="unicode__linebreak">
	<refentryinfo><author><firstname>Sam</firstname><surname>Varshavchik</surname><contrib>Author</contrib></author><productname>Courier Unicode Library</productname></refentryinfo>

	<refmeta>
	  <refentrytitle>unicode::linebreak</refentrytitle>
	  <manvolnum>3</manvolnum>
	</refmeta>

	<refnamediv>
	  <refname>unicode::linebreak_callback_base</refname>
	  <refname>unicode::linebreak_callback_save_buf</refname>
	  <refname>unicode::linebreakc_callback_base</refname>
	  <refname>unicode::linebreak_iter</refname>
	  <refname>unicode::linebreakc_iter</refname>

	  <refpurpose>unicode line-breaking rules</refpurpose>
	</refnamediv>

	<refsynopsisdiv>
	  <programlisting>
#include &lt;courier-unicode.h&gt;

class linebreak : public unicode::linebreak_callback_base {

public:

    using unicode::linebreak_callback_base::operator&lt;&lt;;
    using unicode::linebreak_callback_base::operator();
    int callback(int linebreak_code)
    {
        // ...
    }
};

char32_t c;
std::u32string buf;

linebreak compute_linebreak;

compute_linebreak.set_opts(UNICODE_LB_OPT_SYBREAK);
compute_linebreak &lt;&lt; c;

compute_linebreak(buf);
compute_linebreak(buf.begin(), buf.end());

compute_linebreak.finish();

// ...

unicode::linebreak_callback_save_buf linebreaks;

std::list&lt;int&gt; lb=linebreaks.lb_buf;

class linebreakc : public unicode::linebreakc_callback_base {

public:

    using unicode::linebreak_callback_base::operator&lt;&lt;;
    using unicode::linebreak_callback_base::operator();
    int callback(int linebreak_code, char32_t ch)
    {
        // ...
    }
};

// ...

std::u32string buf;

typedef unicode::linebreak_iter&lt;std::u32string::const_iterator&gt; iter_t;

iter_t beg_iter(buf.begin(), buf.end()), end_iter;

beg_iter.set_opts(UNICODE_LB_OPT_SYBREAK);

std::vector&lt;int&gt; linebreaks;

std::copy(beg_iter, end_iter, std::back_insert_iterator&lt;std::vector&lt;int&gt;&gt;(linebreaks));

// ...

typedef unicode::linebreakc_iter&lt;std::u32string::const_iterator&gt; iter_t;

iter_t beg_iter(buf.begin(), buf.end()), end_iter;

beg_iter.set_opts(UNICODE_LB_OPT_SYBREAK);

std::vector&lt;std::pair&lt;int, char32_t&gt;&gt; linebreaks;

std::copy(beg_iter, end_iter, std::back_insert_iterator&lt;std::vector&lt;int&gt;&gt;(linebreaks));</programlisting>
	</refsynopsisdiv>

	<refsect1>
	  <title>DESCRIPTION</title>

	  <para>
	    <classname>unicode::linebreak_callback_base</classname> is a C++
	    binding for the unicode line-breaking rule implementation described
	    in
	    <link linkend="unicode_line_break">
	      <citerefentry><refentrytitle>unicode_line_break</refentrytitle>
	      <manvolnum>3</manvolnum></citerefentry></link>.
	  </para>

	  <para>
	    Subclass <classname>unicode::linebreak_callback_base</classname>
	    and implement <methodname>callback</methodname>() that's virtually
	    inherited from
	    <classname>unicode::linebreak_callback_base</classname>.
	    The
	    <methodname>callback</methodname>() callback function receives the
	    output values from the line-breaking algorithm, the
	    <literal>UNICODE_LB_MANDATORY</literal>,
	    <literal>UNICODE_LB_NONE</literal>, or the
	    <literal>UNICODE_LB_ALLOWED</literal> value, for each unicode
	    character.
	  </para>

	  <para>
	    <methodname>callback</methodname>() should return 0. A non-zero
	    return reports an error, that stops the line-breaking algorithm.
	    See
	    <link linkend="unicode_line_break">
	      <citerefentry><refentrytitle>unicode_line_break</refentrytitle>
	      <manvolnum>3</manvolnum></citerefentry></link> for more
	      information.
	  </para>

	  <para>
	    The alternate
	    <classname>unicode::linebreakc_callback_base</classname>
	    interface uses a virtually inherited
	    <methodname>callback</methodname>() that receives two parameters,
	    the line-break code value, and the corresponding unicode character.
	  </para>
 	  <para>
	    The input unicode characters for the line-breaking
	    algorithm are provided by the <literal>&lt;&lt;</literal>
	    operator, one unicode character at a time; or by the
	    <literal>()</literal> operator, passing either a container, or
	    a beginning and an ending iterator value for an input sequence
	    of unicode characters. <methodname>finish</methodname>() indicates
	    the end of the unicode character sequence.
	  </para>

	  <para>
	    <methodname>set_opts</methodname> sets line-breaking options
	    (see <methodname>unicode_lb_set_opts</methodname>() for more
	    information).
	  </para>
	  <para>
	    <classname>unicode::linebreak_callback_save_buf</classname> is a
	    subclass that implements <methodname>callback</methodname>() by
	    saving the linebreaks codes into a <classname>std::list</classname>.
	  </para>

	  <para>
	    The <classname>linebreak_iter</classname> template implements an
	    input iterator over <classname>int</classname>s.
	    The template parameter is an input iterator over
	    <classname>unicode</classname> chars. The constructor's parameters
	    are a beginning and an ending iterator value for a sequence of
	    <classname>char32_t</classname>. This constructs the beginning
	    iterator value for a sequence of <classname>int</classname>s
	    consisting of line-break values
	    (<literal>UNICODE_LB_MANDATORY</literal>,
	    <literal>UNICODE_LB_NONE</literal>, or
	    <literal>UNICODE_LB_ALLOWED</literal>) corresponding to each
	    <classname>char32_t</classname> in the underlying sequence.
	    The default constructor creates the ending iterator value for the
	    sequence.
	  </para>

	  <para>
	    The iterator implements a <methodname>set_opts</methodname>()
	    methods that sets the options for the line-breaking algorithm.
	  </para>

	  <para>
	    The <classname>linebreakc_iter</classname> template implements a
	    similar input iterator, with the difference that it ends up iterating
	    over a <classname>std::pair</classname> of line-breaking values and
	    the corresponding <classname>char32_t</classname> from the
	    underlying input sequence.
	  </para>
	</refsect1>

	<refsect1>
	  <title>SEE ALSO</title>
	  <para>
	    <link linkend="courier-unicode">
	      <citerefentry>
		<refentrytitle>courier-unicode</refentrytitle>
		<manvolnum>7</manvolnum></citerefentry></link>,
	    <link linkend="unicode_line_break">
	      <citerefentry><refentrytitle>unicode_line_break</refentrytitle>
	      <manvolnum>3</manvolnum></citerefentry></link>.
	  </para>
	</refsect1>
      </refentry>

      <refentry id="unicode__tolower">
	<refentryinfo><author><firstname>Sam</firstname><surname>Varshavchik</surname><contrib>Author</contrib></author><productname>Courier Unicode Library</productname></refentryinfo>

	<refmeta>
	  <refentrytitle>unicode::tolower</refentrytitle>
	  <manvolnum>3</manvolnum>
	</refmeta>

	<refnamediv>
	  <refname>unicode::tolower</refname>
	  <refname>unicode::toupper</refname>
	  <refpurpose>unicode version of
	  <citerefentry><refentrytitle>tolower</refentrytitle>
	  <manvolnum>3</manvolnum></citerefentry>
	  and
	  <citerefentry><refentrytitle>toupper</refentrytitle>
	  <manvolnum>3</manvolnum></citerefentry>
	  </refpurpose>
	</refnamediv>

	<refsynopsisdiv>
	  <funcsynopsis>
	    <funcsynopsisinfo>#include &lt;courier-unicode.h&gt;</funcsynopsisinfo>
	    <funcprototype>
              <funcdef>std::string <function>unicode::tolower</function></funcdef>
	      <paramdef>const std::string &amp;<parameter>string</parameter></paramdef>
	    </funcprototype>

	    <funcprototype>
              <funcdef>std::string <function>unicode::tolower</function></funcdef>
	      <paramdef>const std::string &amp;<parameter>string</parameter></paramdef>
	      <paramdef>const std::string &amp;<parameter>charset</parameter></paramdef>
	    </funcprototype>

	    <funcprototype>
              <funcdef>std::u32string <function>unicode::tolower</function></funcdef>
	      <paramdef>const std::u32string &amp;<parameter>u</parameter></paramdef>
	    </funcprototype>

	    <funcprototype>
              <funcdef>std::string <function>unicode::toupper</function></funcdef>
	      <paramdef>const std::string &amp;<parameter>string</parameter></paramdef>
	    </funcprototype>

	    <funcprototype>
              <funcdef>std::string <function>unicode::toupper</function></funcdef>
	      <paramdef>const std::string &amp;<parameter>string</parameter></paramdef>
	      <paramdef>const std::string &amp;<parameter>charset</parameter></paramdef>
	    </funcprototype>

	    <funcprototype>
              <funcdef>std::u32string <function>unicode::toupper</function></funcdef>
	      <paramdef>const std::u32string &amp;<parameter>u</parameter></paramdef>
	    </funcprototype>
	  </funcsynopsis>
	</refsynopsisdiv>

	<refsect1>
	  <title>DESCRIPTION</title>

	  <para>
	    These functions convert the <replaceable>string</replaceable>
	    parameter, in <replaceable>charset</replaceable> or
	    <link linkend="unicode_default_chset">
	      <citerefentry><refentrytitle>unicode_default_chset</refentrytitle>
	      <manvolnum>3</manvolnum></citerefentry></link>,
	      to unicode, replace each character with
	      <link linkend="unicode_uc">
		<citerefentry><refentrytitle>unicode_lc</refentrytitle>
		<manvolnum>3</manvolnum></citerefentry></link> or
	      <link linkend="unicode_uc">
		<citerefentry><refentrytitle>unicode_uc</refentrytitle>
		<manvolnum>3</manvolnum></citerefentry></link>,
		then convert it back to the same character set, returning
		the resulting string.
	  </para>

	  <para>
	    Passing a
	    <classname>const std::u32string &amp;</classname>
	    directly also converts it accordingly, returning the converted
	    unicode string.
	  </para>
	</refsect1>

	<refsect1>
	  <title>SEE ALSO</title>
	  <para>
	    <link linkend="courier-unicode">
	      <citerefentry>
		<refentrytitle>courier-unicode</refentrytitle>
		<manvolnum>7</manvolnum></citerefentry></link>.
	  </para>
	</refsect1>
      </refentry>

      <refentry id="unicode__wordbreak">
	<refentryinfo><author><firstname>Sam</firstname><surname>Varshavchik</surname><contrib>Author</contrib></author><productname>Courier Unicode Library</productname></refentryinfo>

	<refmeta>
	  <refentrytitle>unicode::wordbreak</refentrytitle>
	  <manvolnum>3</manvolnum>
	</refmeta>

	<refnamediv>
	  <refname>unicode::wordbreak_callback_base</refname>
	  <refname>unicode::wordbreak_callback_base</refname>
	  <refpurpose>unicode word-breaking rules</refpurpose>
	</refnamediv>

	<refsynopsisdiv>
	  <programlisting>
#include &lt;courier-unicode.h&gt;

class wordbreak : public unicode::wordbreak_callback_base {

public:

    using unicode::wordbreak_callback_base::operator&lt;&lt;;
    using unicode::wordbreak_callback_base::operator();
    int callback(bool flag)
    {
        // ...
    }
};

char32_t c;
std::u32string buf;

wordbreak compute_wordbreak;

compute_wordbreak &lt;&lt; c;

compute_wordbreak(buf);
compute_wordbreak(buf.begin(), buf.end());

compute_wordbreak.finish();

// ...

unicode_wordbreakscan scan;

scan &lt;&lt; c;

size_t nchars=scan.finish();

</programlisting>
	</refsynopsisdiv>

	<refsect1>
	  <title>DESCRIPTION</title>

	  <para>
	    <classname>unicode::wordbreak_callback_base</classname> is a C++
	    binding for the unicode word-breaking rule implementation described
	    in
	    <link linkend="unicode_word_break">
	      <citerefentry><refentrytitle>unicode_word_break</refentrytitle>
	      <manvolnum>3</manvolnum></citerefentry></link>.
	  </para>

	  <para>
	    Subclass <classname>unicode::wordbreak_callback_base</classname>
	    and implement <methodname>callback</methodname>() that's virtually
	    inherited from
	    <classname>unicode::wordbreak_callback_base</classname>.
	    The
	    <methodname>callback</methodname>() callback function receives the
	    output values from the word-breaking algorithm, namely a
	    <classname>bool</classname> indicating whether a word break
	    exists before the unicode character in the underlying input sequence.
	  </para>

	  <para>
	    <methodname>callback</methodname>() should return 0. A non-zero
	    return reports an error, that stops the word-breaking algorithm.
	    See
	    <link linkend="unicode_word_break">
	      <citerefentry><refentrytitle>unicode_word_break</refentrytitle>
	      <manvolnum>3</manvolnum></citerefentry></link> for more
	      information.
	  </para>

 	  <para>
	    The input unicode characters for the word-breaking
	    algorithm are provided by the <literal>&lt;&lt;</literal>
	    operator, one unicode character at a time; or by the
	    <literal>()</literal> operator, passing either a container, or
	    a beginning and an ending iterator value for an input sequence
	    of unicode characters. <methodname>finish</methodname>() indicates
	    the end of the unicode character sequence.
	  </para>

	  <para>
	    <classname>unicode::wordbreakscan</classname> is a C++
	    binding for the
	    <function>unicode_wbscan_init</function>(),
            <function>unicode_wbscan_next</function>() and
            <function>unicode_wbscan_end</function>
	    methods described in
	    <link linkend="unicode_word_break">
	      <citerefentry><refentrytitle>unicode_word_break</refentrytitle>
	      <manvolnum>3</manvolnum></citerefentry></link>.
	      Its <methodname>&lt;&lt;</methodname> iterates over the
	      unicode characters, and <methodname>finish</methodname>()
	      indicates the number of characters before the first unicode
	      word break. The <methodname>&lt;&lt;</methodname> iterator
	      returns a <classname>bool</classname> indicating when the first
	      word break has already been found, so further calls are not
	      necessary.
	  </para>
	</refsect1>

	<refsect1>
	  <title>SEE ALSO</title>
	  <para>
	    <link linkend="courier-unicode">
	      <citerefentry>
		<refentrytitle>courier-unicode</refentrytitle>
		<manvolnum>7</manvolnum></citerefentry></link>,
	    <link linkend="unicode_word_break">
	      <citerefentry><refentrytitle>unicode_word_break</refentrytitle>
	      <manvolnum>3</manvolnum></citerefentry></link>.
	  </para>
	</refsect1>
      </refentry>

    </section>
  </section>
  <section id="COPYING">
    <title>COPYING</title>

    <para role="COPYING">
      The Courier Unicode Library is free software, distributed under the
      terms of the GPL, version 3:
    </para>
    <blockquote>
      <literallayout><xi:include href="COPYING" parse="text" xmlns:xi="http://www.w3.org/2001/XInclude" /></literallayout>
    </blockquote>
  </section>
</article>
